// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#include "Protocol.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
#include "google/protobuf/generated_message_tctable_impl.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;

inline constexpr VECTOR4::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : x_{0},
        y_{0},
        z_{0},
        w_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR VECTOR4::VECTOR4(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct VECTOR4DefaultTypeInternal {
  PROTOBUF_CONSTEXPR VECTOR4DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VECTOR4DefaultTypeInternal() {}
  union {
    VECTOR4 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VECTOR4DefaultTypeInternal _VECTOR4_default_instance_;

inline constexpr VECTOR3::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : x_{0},
        y_{0},
        z_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR VECTOR3::VECTOR3(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct VECTOR3DefaultTypeInternal {
  PROTOBUF_CONSTEXPR VECTOR3DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VECTOR3DefaultTypeInternal() {}
  union {
    VECTOR3 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VECTOR3DefaultTypeInternal _VECTOR3_default_instance_;

inline constexpr SC_STATICOBJFIND::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : id_{::int64_t{0}},
        enable_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR SC_STATICOBJFIND::SC_STATICOBJFIND(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct SC_STATICOBJFINDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SC_STATICOBJFINDDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SC_STATICOBJFINDDefaultTypeInternal() {}
  union {
    SC_STATICOBJFIND _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SC_STATICOBJFINDDefaultTypeInternal _SC_STATICOBJFIND_default_instance_;

inline constexpr SC_SEEPLAYERMOVE::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : id_{::int64_t{0}},
        posx_{0},
        posy_{0},
        posz_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR SC_SEEPLAYERMOVE::SC_SEEPLAYERMOVE(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct SC_SEEPLAYERMOVEDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SC_SEEPLAYERMOVEDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SC_SEEPLAYERMOVEDefaultTypeInternal() {}
  union {
    SC_SEEPLAYERMOVE _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SC_SEEPLAYERMOVEDefaultTypeInternal _SC_SEEPLAYERMOVE_default_instance_;

inline constexpr SC_OTHERCLIENTLOGIN::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : id_{::int64_t{0}},
        cellindex_{0},
        type_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR SC_OTHERCLIENTLOGIN::SC_OTHERCLIENTLOGIN(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct SC_OTHERCLIENTLOGINDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SC_OTHERCLIENTLOGINDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SC_OTHERCLIENTLOGINDefaultTypeInternal() {}
  union {
    SC_OTHERCLIENTLOGIN _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SC_OTHERCLIENTLOGINDefaultTypeInternal _SC_OTHERCLIENTLOGIN_default_instance_;

inline constexpr SC_MONSTERFIND::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : id_{::int64_t{0}},
        targetid_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR SC_MONSTERFIND::SC_MONSTERFIND(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct SC_MONSTERFINDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SC_MONSTERFINDDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SC_MONSTERFINDDefaultTypeInternal() {}
  union {
    SC_MONSTERFIND _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SC_MONSTERFINDDefaultTypeInternal _SC_MONSTERFIND_default_instance_;

inline constexpr SC_HARLEQUINTHROWING::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : id_{0},
        posx_{0},
        posy_{0},
        posz_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR SC_HARLEQUINTHROWING::SC_HARLEQUINTHROWING(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct SC_HARLEQUINTHROWINGDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SC_HARLEQUINTHROWINGDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SC_HARLEQUINTHROWINGDefaultTypeInternal() {}
  union {
    SC_HARLEQUINTHROWING _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SC_HARLEQUINTHROWINGDefaultTypeInternal _SC_HARLEQUINTHROWING_default_instance_;

inline constexpr SC_DAMAGED::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : id_{::int64_t{0}},
        hp_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR SC_DAMAGED::SC_DAMAGED(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct SC_DAMAGEDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SC_DAMAGEDDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SC_DAMAGEDDefaultTypeInternal() {}
  union {
    SC_DAMAGED _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SC_DAMAGEDDefaultTypeInternal _SC_DAMAGED_default_instance_;

inline constexpr SC_CONNECTSUCCESS::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : id_{::int64_t{0}},
        cellindex_{0},
        type_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR SC_CONNECTSUCCESS::SC_CONNECTSUCCESS(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct SC_CONNECTSUCCESSDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SC_CONNECTSUCCESSDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SC_CONNECTSUCCESSDefaultTypeInternal() {}
  union {
    SC_CONNECTSUCCESS _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SC_CONNECTSUCCESSDefaultTypeInternal _SC_CONNECTSUCCESS_default_instance_;

inline constexpr MOBSTATE::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : id_{::int64_t{0}},
        posx_{0},
        posy_{0},
        posz_{0},
        rotatex_{0},
        rotatey_{0},
        rotatez_{0},
        animationindex_{0},
        state_{0},
        triggeron_{false},
        foundon_{false},
        damageon_{false},
        remain2_{false},
        animtime_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR MOBSTATE::MOBSTATE(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct MOBSTATEDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MOBSTATEDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MOBSTATEDefaultTypeInternal() {}
  union {
    MOBSTATE _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MOBSTATEDefaultTypeInternal _MOBSTATE_default_instance_;

inline constexpr EQINFO::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : gold_{0},
        increasepower_{0},
        increasedefensive_{0},
        increasehp_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR EQINFO::EQINFO(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct EQINFODefaultTypeInternal {
  PROTOBUF_CONSTEXPR EQINFODefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EQINFODefaultTypeInternal() {}
  union {
    EQINFO _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EQINFODefaultTypeInternal _EQINFO_default_instance_;

inline constexpr CS_PRESSKEY::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : id_{::int64_t{0}},
        key_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CS_PRESSKEY::CS_PRESSKEY(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CS_PRESSKEYDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CS_PRESSKEYDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CS_PRESSKEYDefaultTypeInternal() {}
  union {
    CS_PRESSKEY _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CS_PRESSKEYDefaultTypeInternal _CS_PRESSKEY_default_instance_;

inline constexpr CS_PLAYERORDER::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : id_{::int64_t{0}},
        order_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CS_PLAYERORDER::CS_PLAYERORDER(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CS_PLAYERORDERDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CS_PLAYERORDERDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CS_PLAYERORDERDefaultTypeInternal() {}
  union {
    CS_PLAYERORDER _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CS_PLAYERORDERDefaultTypeInternal _CS_PLAYERORDER_default_instance_;

inline constexpr CS_LOGIN::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : id_{::int64_t{0}},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CS_LOGIN::CS_LOGIN(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CS_LOGINDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CS_LOGINDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CS_LOGINDefaultTypeInternal() {}
  union {
    CS_LOGIN _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CS_LOGINDefaultTypeInternal _CS_LOGIN_default_instance_;

inline constexpr CS_HEAL::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : id_{::int64_t{0}},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CS_HEAL::CS_HEAL(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CS_HEALDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CS_HEALDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CS_HEALDefaultTypeInternal() {}
  union {
    CS_HEAL _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CS_HEALDefaultTypeInternal _CS_HEAL_default_instance_;

inline constexpr CS_DISCONNECT::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : id_{::int64_t{0}},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CS_DISCONNECT::CS_DISCONNECT(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CS_DISCONNECTDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CS_DISCONNECTDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CS_DISCONNECTDefaultTypeInternal() {}
  union {
    CS_DISCONNECT _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CS_DISCONNECTDefaultTypeInternal _CS_DISCONNECT_default_instance_;

inline constexpr CS_DAMAGED::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : id_{::int64_t{0}},
        damage_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CS_DAMAGED::CS_DAMAGED(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CS_DAMAGEDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CS_DAMAGEDDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CS_DAMAGEDDefaultTypeInternal() {}
  union {
    CS_DAMAGED _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CS_DAMAGEDDefaultTypeInternal _CS_DAMAGED_default_instance_;

inline constexpr COLLISIONDATA::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : id_{::int64_t{0}},
        enemyid_{::int64_t{0}},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR COLLISIONDATA::COLLISIONDATA(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct COLLISIONDATADefaultTypeInternal {
  PROTOBUF_CONSTEXPR COLLISIONDATADefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~COLLISIONDATADefaultTypeInternal() {}
  union {
    COLLISIONDATA _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 COLLISIONDATADefaultTypeInternal _COLLISIONDATA_default_instance_;

inline constexpr CHARSTATE::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : id_{::int64_t{0}},
        posx_{0},
        posy_{0},
        posz_{0},
        rotatex_{0},
        rotatey_{0},
        rotatez_{0},
        animationindex_{0},
        state_{0},
        triggeron_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CHARSTATE::CHARSTATE(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CHARSTATEDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CHARSTATEDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CHARSTATEDefaultTypeInternal() {}
  union {
    CHARSTATE _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CHARSTATEDefaultTypeInternal _CHARSTATE_default_instance_;

inline constexpr CS_ATTACK::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        attackpos_{nullptr},
        id_{::int64_t{0}},
        damage_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CS_ATTACK::CS_ATTACK(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CS_ATTACKDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CS_ATTACKDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CS_ATTACKDefaultTypeInternal() {}
  union {
    CS_ATTACK _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CS_ATTACKDefaultTypeInternal _CS_ATTACK_default_instance_;
static ::_pb::Metadata file_level_metadata_Protocol_2eproto[20];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_Protocol_2eproto[1];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_Protocol_2eproto = nullptr;
const ::uint32_t TableStruct_Protocol_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::VECTOR3, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::VECTOR3, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::VECTOR3, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::VECTOR3, _impl_.z_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::VECTOR4, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::VECTOR4, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::VECTOR4, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::VECTOR4, _impl_.z_),
    PROTOBUF_FIELD_OFFSET(::VECTOR4, _impl_.w_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::EQINFO, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::EQINFO, _impl_.gold_),
    PROTOBUF_FIELD_OFFSET(::EQINFO, _impl_.increasepower_),
    PROTOBUF_FIELD_OFFSET(::EQINFO, _impl_.increasedefensive_),
    PROTOBUF_FIELD_OFFSET(::EQINFO, _impl_.increasehp_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::CHARSTATE, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CHARSTATE, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::CHARSTATE, _impl_.posx_),
    PROTOBUF_FIELD_OFFSET(::CHARSTATE, _impl_.posy_),
    PROTOBUF_FIELD_OFFSET(::CHARSTATE, _impl_.posz_),
    PROTOBUF_FIELD_OFFSET(::CHARSTATE, _impl_.rotatex_),
    PROTOBUF_FIELD_OFFSET(::CHARSTATE, _impl_.rotatey_),
    PROTOBUF_FIELD_OFFSET(::CHARSTATE, _impl_.rotatez_),
    PROTOBUF_FIELD_OFFSET(::CHARSTATE, _impl_.animationindex_),
    PROTOBUF_FIELD_OFFSET(::CHARSTATE, _impl_.state_),
    PROTOBUF_FIELD_OFFSET(::CHARSTATE, _impl_.triggeron_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::MOBSTATE, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::MOBSTATE, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::MOBSTATE, _impl_.posx_),
    PROTOBUF_FIELD_OFFSET(::MOBSTATE, _impl_.posy_),
    PROTOBUF_FIELD_OFFSET(::MOBSTATE, _impl_.posz_),
    PROTOBUF_FIELD_OFFSET(::MOBSTATE, _impl_.rotatex_),
    PROTOBUF_FIELD_OFFSET(::MOBSTATE, _impl_.rotatey_),
    PROTOBUF_FIELD_OFFSET(::MOBSTATE, _impl_.rotatez_),
    PROTOBUF_FIELD_OFFSET(::MOBSTATE, _impl_.animationindex_),
    PROTOBUF_FIELD_OFFSET(::MOBSTATE, _impl_.state_),
    PROTOBUF_FIELD_OFFSET(::MOBSTATE, _impl_.triggeron_),
    PROTOBUF_FIELD_OFFSET(::MOBSTATE, _impl_.foundon_),
    PROTOBUF_FIELD_OFFSET(::MOBSTATE, _impl_.damageon_),
    PROTOBUF_FIELD_OFFSET(::MOBSTATE, _impl_.remain2_),
    PROTOBUF_FIELD_OFFSET(::MOBSTATE, _impl_.animtime_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::COLLISIONDATA, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::COLLISIONDATA, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::COLLISIONDATA, _impl_.enemyid_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::SC_CONNECTSUCCESS, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::SC_CONNECTSUCCESS, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::SC_CONNECTSUCCESS, _impl_.cellindex_),
    PROTOBUF_FIELD_OFFSET(::SC_CONNECTSUCCESS, _impl_.type_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::SC_OTHERCLIENTLOGIN, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::SC_OTHERCLIENTLOGIN, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::SC_OTHERCLIENTLOGIN, _impl_.cellindex_),
    PROTOBUF_FIELD_OFFSET(::SC_OTHERCLIENTLOGIN, _impl_.type_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::SC_MONSTERFIND, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::SC_MONSTERFIND, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::SC_MONSTERFIND, _impl_.targetid_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::SC_DAMAGED, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::SC_DAMAGED, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::SC_DAMAGED, _impl_.hp_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::SC_SEEPLAYERMOVE, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::SC_SEEPLAYERMOVE, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::SC_SEEPLAYERMOVE, _impl_.posx_),
    PROTOBUF_FIELD_OFFSET(::SC_SEEPLAYERMOVE, _impl_.posy_),
    PROTOBUF_FIELD_OFFSET(::SC_SEEPLAYERMOVE, _impl_.posz_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::SC_STATICOBJFIND, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::SC_STATICOBJFIND, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::SC_STATICOBJFIND, _impl_.enable_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::SC_HARLEQUINTHROWING, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::SC_HARLEQUINTHROWING, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::SC_HARLEQUINTHROWING, _impl_.posx_),
    PROTOBUF_FIELD_OFFSET(::SC_HARLEQUINTHROWING, _impl_.posy_),
    PROTOBUF_FIELD_OFFSET(::SC_HARLEQUINTHROWING, _impl_.posz_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::CS_LOGIN, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CS_LOGIN, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::CS_ATTACK, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::CS_ATTACK, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CS_ATTACK, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::CS_ATTACK, _impl_.attackpos_),
    PROTOBUF_FIELD_OFFSET(::CS_ATTACK, _impl_.damage_),
    ~0u,
    0,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::CS_HEAL, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CS_HEAL, _impl_.id_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::CS_PRESSKEY, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CS_PRESSKEY, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::CS_PRESSKEY, _impl_.key_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::CS_PLAYERORDER, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CS_PLAYERORDER, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::CS_PLAYERORDER, _impl_.order_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::CS_DAMAGED, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CS_DAMAGED, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::CS_DAMAGED, _impl_.damage_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::CS_DISCONNECT, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::CS_DISCONNECT, _impl_.id_),
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        {0, -1, -1, sizeof(::VECTOR3)},
        {11, -1, -1, sizeof(::VECTOR4)},
        {23, -1, -1, sizeof(::EQINFO)},
        {35, -1, -1, sizeof(::CHARSTATE)},
        {53, -1, -1, sizeof(::MOBSTATE)},
        {75, -1, -1, sizeof(::COLLISIONDATA)},
        {85, -1, -1, sizeof(::SC_CONNECTSUCCESS)},
        {96, -1, -1, sizeof(::SC_OTHERCLIENTLOGIN)},
        {107, -1, -1, sizeof(::SC_MONSTERFIND)},
        {117, -1, -1, sizeof(::SC_DAMAGED)},
        {127, -1, -1, sizeof(::SC_SEEPLAYERMOVE)},
        {139, -1, -1, sizeof(::SC_STATICOBJFIND)},
        {149, -1, -1, sizeof(::SC_HARLEQUINTHROWING)},
        {161, -1, -1, sizeof(::CS_LOGIN)},
        {170, 181, -1, sizeof(::CS_ATTACK)},
        {184, -1, -1, sizeof(::CS_HEAL)},
        {193, -1, -1, sizeof(::CS_PRESSKEY)},
        {203, -1, -1, sizeof(::CS_PLAYERORDER)},
        {213, -1, -1, sizeof(::CS_DAMAGED)},
        {223, -1, -1, sizeof(::CS_DISCONNECT)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::_VECTOR3_default_instance_._instance,
    &::_VECTOR4_default_instance_._instance,
    &::_EQINFO_default_instance_._instance,
    &::_CHARSTATE_default_instance_._instance,
    &::_MOBSTATE_default_instance_._instance,
    &::_COLLISIONDATA_default_instance_._instance,
    &::_SC_CONNECTSUCCESS_default_instance_._instance,
    &::_SC_OTHERCLIENTLOGIN_default_instance_._instance,
    &::_SC_MONSTERFIND_default_instance_._instance,
    &::_SC_DAMAGED_default_instance_._instance,
    &::_SC_SEEPLAYERMOVE_default_instance_._instance,
    &::_SC_STATICOBJFIND_default_instance_._instance,
    &::_SC_HARLEQUINTHROWING_default_instance_._instance,
    &::_CS_LOGIN_default_instance_._instance,
    &::_CS_ATTACK_default_instance_._instance,
    &::_CS_HEAL_default_instance_._instance,
    &::_CS_PRESSKEY_default_instance_._instance,
    &::_CS_PLAYERORDER_default_instance_._instance,
    &::_CS_DAMAGED_default_instance_._instance,
    &::_CS_DISCONNECT_default_instance_._instance,
};
const char descriptor_table_protodef_Protocol_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\016Protocol.proto\"*\n\007VECTOR3\022\t\n\001x\030\001 \001(\002\022\t"
    "\n\001y\030\002 \001(\002\022\t\n\001z\030\003 \001(\002\"5\n\007VECTOR4\022\t\n\001x\030\001 \001"
    "(\002\022\t\n\001y\030\002 \001(\002\022\t\n\001z\030\003 \001(\002\022\t\n\001w\030\004 \001(\002\"\\\n\006E"
    "QINFO\022\014\n\004gold\030\001 \001(\002\022\025\n\rincreasePower\030\002 \001"
    "(\002\022\031\n\021increaseDefensive\030\003 \001(\002\022\022\n\nincreas"
    "eHp\030\004 \001(\002\"\256\001\n\tCHARSTATE\022\n\n\002id\030\001 \001(\003\022\014\n\004p"
    "osx\030\002 \001(\002\022\014\n\004posy\030\003 \001(\002\022\014\n\004posz\030\004 \001(\002\022\017\n"
    "\007rotatex\030\005 \001(\002\022\017\n\007rotatey\030\006 \001(\002\022\017\n\007rotat"
    "ez\030\007 \001(\002\022\026\n\016animationIndex\030\010 \001(\005\022\r\n\005stat"
    "e\030\t \001(\005\022\021\n\ttriggerOn\030\n \001(\005\"\363\001\n\010MOBSTATE\022"
    "\n\n\002id\030\001 \001(\003\022\014\n\004posx\030\002 \001(\002\022\014\n\004posy\030\003 \001(\002\022"
    "\014\n\004posz\030\004 \001(\002\022\017\n\007rotatex\030\005 \001(\002\022\017\n\007rotate"
    "y\030\006 \001(\002\022\017\n\007rotatez\030\007 \001(\002\022\026\n\016animationInd"
    "ex\030\010 \001(\005\022\r\n\005state\030\t \001(\005\022\021\n\ttriggerOn\030\n \001"
    "(\010\022\017\n\007foundOn\030\013 \001(\010\022\020\n\010damageOn\030\014 \001(\010\022\017\n"
    "\007remain2\030\r \001(\010\022\020\n\010animtime\030\016 \001(\002\",\n\rCOLL"
    "ISIONDATA\022\n\n\002id\030\001 \001(\003\022\017\n\007enemyID\030\002 \001(\003\"@"
    "\n\021SC_CONNECTSUCCESS\022\n\n\002id\030\001 \001(\003\022\021\n\tcellI"
    "ndex\030\002 \001(\005\022\014\n\004type\030\004 \001(\005\"B\n\023SC_OTHERCLIE"
    "NTLOGIN\022\n\n\002id\030\001 \001(\003\022\021\n\tcellIndex\030\002 \001(\005\022\014"
    "\n\004type\030\003 \001(\005\".\n\016SC_MONSTERFIND\022\n\n\002id\030\001 \001"
    "(\003\022\020\n\010targetID\030\002 \001(\005\"$\n\nSC_DAMAGED\022\n\n\002id"
    "\030\001 \001(\003\022\n\n\002hp\030\002 \001(\002\"H\n\020SC_SEEPLAYERMOVE\022\n"
    "\n\002id\030\001 \001(\003\022\014\n\004posX\030\002 \001(\002\022\014\n\004posY\030\003 \001(\002\022\014"
    "\n\004posZ\030\004 \001(\002\".\n\020SC_STATICOBJFIND\022\n\n\002id\030\001"
    " \001(\003\022\016\n\006enable\030\002 \001(\005\"L\n\024SC_HARLEQUINTHRO"
    "WING\022\n\n\002id\030\001 \001(\005\022\014\n\004posX\030\002 \001(\002\022\014\n\004posY\030\003"
    " \001(\002\022\014\n\004posZ\030\004 \001(\002\"\026\n\010CS_LOGIN\022\n\n\002id\030\001 \001"
    "(\003\"D\n\tCS_ATTACK\022\n\n\002id\030\001 \001(\003\022\033\n\tattackPos"
    "\030\002 \001(\0132\010.VECTOR3\022\016\n\006damage\030\003 \001(\002\"\025\n\007CS_H"
    "EAL\022\n\n\002id\030\001 \001(\003\"&\n\013CS_PRESSKEY\022\n\n\002id\030\001 \001"
    "(\003\022\013\n\003key\030\002 \001(\005\"+\n\016CS_PLAYERORDER\022\n\n\002id\030"
    "\001 \001(\003\022\r\n\005order\030\002 \001(\005\"(\n\nCS_DAMAGED\022\n\n\002id"
    "\030\001 \001(\003\022\016\n\006damage\030\002 \001(\002\"\033\n\rCS_DISCONNECT\022"
    "\n\n\002id\030\001 \001(\003*2\n\tDirection\022\006\n\002UP\020\000\022\010\n\004DOWN"
    "\020\001\022\010\n\004LEFT\020\002\022\t\n\005RIGHT\020\003b\006proto3"
};
static ::absl::once_flag descriptor_table_Protocol_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_Protocol_2eproto = {
    false,
    false,
    1431,
    descriptor_table_protodef_Protocol_2eproto,
    "Protocol.proto",
    &descriptor_table_Protocol_2eproto_once,
    nullptr,
    0,
    20,
    schemas,
    file_default_instances,
    TableStruct_Protocol_2eproto::offsets,
    file_level_metadata_Protocol_2eproto,
    file_level_enum_descriptors_Protocol_2eproto,
    file_level_service_descriptors_Protocol_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_Protocol_2eproto_getter() {
  return &descriptor_table_Protocol_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_Protocol_2eproto(&descriptor_table_Protocol_2eproto);
const ::google::protobuf::EnumDescriptor* Direction_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_Protocol_2eproto);
  return file_level_enum_descriptors_Protocol_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t Direction_internal_data_[] = {
    262144u, 0u, };
bool Direction_IsValid(int value) {
  return 0 <= value && value <= 3;
}
// ===================================================================

class VECTOR3::_Internal {
 public:
};

VECTOR3::VECTOR3(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:VECTOR3)
}
VECTOR3::VECTOR3(
    ::google::protobuf::Arena* arena, const VECTOR3& from)
    : VECTOR3(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE VECTOR3::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void VECTOR3::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, x_),
           0,
           offsetof(Impl_, z_) -
               offsetof(Impl_, x_) +
               sizeof(Impl_::z_));
}
VECTOR3::~VECTOR3() {
  // @@protoc_insertion_point(destructor:VECTOR3)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VECTOR3::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void VECTOR3::Clear() {
// @@protoc_insertion_point(message_clear_start:VECTOR3)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VECTOR3::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> VECTOR3::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_VECTOR3_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // float x = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(VECTOR3, _impl_.x_)}},
    // float y = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(VECTOR3, _impl_.y_)}},
    // float z = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(VECTOR3, _impl_.z_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float x = 1;
    {PROTOBUF_FIELD_OFFSET(VECTOR3, _impl_.x_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float y = 2;
    {PROTOBUF_FIELD_OFFSET(VECTOR3, _impl_.y_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float z = 3;
    {PROTOBUF_FIELD_OFFSET(VECTOR3, _impl_.z_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* VECTOR3::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VECTOR3)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_y(), target);
  }

  // float z = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  ::uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VECTOR3)
  return target;
}

::size_t VECTOR3::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VECTOR3)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 5;
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 5;
  }

  // float z = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  ::uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VECTOR3::_class_data_ = {
    VECTOR3::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* VECTOR3::GetClassData() const {
  return &_class_data_;
}

void VECTOR3::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VECTOR3*>(&to_msg);
  auto& from = static_cast<const VECTOR3&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VECTOR3)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  ::uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VECTOR3::CopyFrom(const VECTOR3& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VECTOR3)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VECTOR3::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* VECTOR3::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void VECTOR3::InternalSwap(VECTOR3* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VECTOR3, _impl_.z_)
      + sizeof(VECTOR3::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(VECTOR3, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata VECTOR3::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[0]);
}
// ===================================================================

class VECTOR4::_Internal {
 public:
};

VECTOR4::VECTOR4(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:VECTOR4)
}
VECTOR4::VECTOR4(
    ::google::protobuf::Arena* arena, const VECTOR4& from)
    : VECTOR4(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE VECTOR4::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void VECTOR4::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, x_),
           0,
           offsetof(Impl_, w_) -
               offsetof(Impl_, x_) +
               sizeof(Impl_::w_));
}
VECTOR4::~VECTOR4() {
  // @@protoc_insertion_point(destructor:VECTOR4)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void VECTOR4::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void VECTOR4::Clear() {
// @@protoc_insertion_point(message_clear_start:VECTOR4)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.w_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.w_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* VECTOR4::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> VECTOR4::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_VECTOR4_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // float w = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(VECTOR4, _impl_.w_)}},
    // float x = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(VECTOR4, _impl_.x_)}},
    // float y = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(VECTOR4, _impl_.y_)}},
    // float z = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(VECTOR4, _impl_.z_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float x = 1;
    {PROTOBUF_FIELD_OFFSET(VECTOR4, _impl_.x_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float y = 2;
    {PROTOBUF_FIELD_OFFSET(VECTOR4, _impl_.y_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float z = 3;
    {PROTOBUF_FIELD_OFFSET(VECTOR4, _impl_.z_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float w = 4;
    {PROTOBUF_FIELD_OFFSET(VECTOR4, _impl_.w_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* VECTOR4::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:VECTOR4)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_y(), target);
  }

  // float z = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  ::uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_z(), target);
  }

  // float w = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_w = this->_internal_w();
  ::uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_w(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:VECTOR4)
  return target;
}

::size_t VECTOR4::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:VECTOR4)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 5;
  }

  // float y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 5;
  }

  // float z = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  ::uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 5;
  }

  // float w = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_w = this->_internal_w();
  ::uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData VECTOR4::_class_data_ = {
    VECTOR4::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* VECTOR4::GetClassData() const {
  return &_class_data_;
}

void VECTOR4::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<VECTOR4*>(&to_msg);
  auto& from = static_cast<const VECTOR4&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:VECTOR4)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  ::uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_w = from._internal_w();
  ::uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    _this->_internal_set_w(from._internal_w());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void VECTOR4::CopyFrom(const VECTOR4& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:VECTOR4)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool VECTOR4::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* VECTOR4::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void VECTOR4::InternalSwap(VECTOR4* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VECTOR4, _impl_.w_)
      + sizeof(VECTOR4::_impl_.w_)
      - PROTOBUF_FIELD_OFFSET(VECTOR4, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata VECTOR4::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[1]);
}
// ===================================================================

class EQINFO::_Internal {
 public:
};

EQINFO::EQINFO(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:EQINFO)
}
EQINFO::EQINFO(
    ::google::protobuf::Arena* arena, const EQINFO& from)
    : EQINFO(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE EQINFO::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void EQINFO::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, gold_),
           0,
           offsetof(Impl_, increasehp_) -
               offsetof(Impl_, gold_) +
               sizeof(Impl_::increasehp_));
}
EQINFO::~EQINFO() {
  // @@protoc_insertion_point(destructor:EQINFO)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void EQINFO::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void EQINFO::Clear() {
// @@protoc_insertion_point(message_clear_start:EQINFO)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.gold_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.increasehp_) -
      reinterpret_cast<char*>(&_impl_.gold_)) + sizeof(_impl_.increasehp_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* EQINFO::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> EQINFO::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_EQINFO_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // float increaseHp = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(EQINFO, _impl_.increasehp_)}},
    // float gold = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(EQINFO, _impl_.gold_)}},
    // float increasePower = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(EQINFO, _impl_.increasepower_)}},
    // float increaseDefensive = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(EQINFO, _impl_.increasedefensive_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float gold = 1;
    {PROTOBUF_FIELD_OFFSET(EQINFO, _impl_.gold_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float increasePower = 2;
    {PROTOBUF_FIELD_OFFSET(EQINFO, _impl_.increasepower_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float increaseDefensive = 3;
    {PROTOBUF_FIELD_OFFSET(EQINFO, _impl_.increasedefensive_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float increaseHp = 4;
    {PROTOBUF_FIELD_OFFSET(EQINFO, _impl_.increasehp_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* EQINFO::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:EQINFO)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float gold = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_gold = this->_internal_gold();
  ::uint32_t raw_gold;
  memcpy(&raw_gold, &tmp_gold, sizeof(tmp_gold));
  if (raw_gold != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_gold(), target);
  }

  // float increasePower = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_increasepower = this->_internal_increasepower();
  ::uint32_t raw_increasepower;
  memcpy(&raw_increasepower, &tmp_increasepower, sizeof(tmp_increasepower));
  if (raw_increasepower != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_increasepower(), target);
  }

  // float increaseDefensive = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_increasedefensive = this->_internal_increasedefensive();
  ::uint32_t raw_increasedefensive;
  memcpy(&raw_increasedefensive, &tmp_increasedefensive, sizeof(tmp_increasedefensive));
  if (raw_increasedefensive != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_increasedefensive(), target);
  }

  // float increaseHp = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_increasehp = this->_internal_increasehp();
  ::uint32_t raw_increasehp;
  memcpy(&raw_increasehp, &tmp_increasehp, sizeof(tmp_increasehp));
  if (raw_increasehp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_increasehp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:EQINFO)
  return target;
}

::size_t EQINFO::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:EQINFO)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float gold = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_gold = this->_internal_gold();
  ::uint32_t raw_gold;
  memcpy(&raw_gold, &tmp_gold, sizeof(tmp_gold));
  if (raw_gold != 0) {
    total_size += 5;
  }

  // float increasePower = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_increasepower = this->_internal_increasepower();
  ::uint32_t raw_increasepower;
  memcpy(&raw_increasepower, &tmp_increasepower, sizeof(tmp_increasepower));
  if (raw_increasepower != 0) {
    total_size += 5;
  }

  // float increaseDefensive = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_increasedefensive = this->_internal_increasedefensive();
  ::uint32_t raw_increasedefensive;
  memcpy(&raw_increasedefensive, &tmp_increasedefensive, sizeof(tmp_increasedefensive));
  if (raw_increasedefensive != 0) {
    total_size += 5;
  }

  // float increaseHp = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_increasehp = this->_internal_increasehp();
  ::uint32_t raw_increasehp;
  memcpy(&raw_increasehp, &tmp_increasehp, sizeof(tmp_increasehp));
  if (raw_increasehp != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData EQINFO::_class_data_ = {
    EQINFO::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* EQINFO::GetClassData() const {
  return &_class_data_;
}

void EQINFO::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<EQINFO*>(&to_msg);
  auto& from = static_cast<const EQINFO&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:EQINFO)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_gold = from._internal_gold();
  ::uint32_t raw_gold;
  memcpy(&raw_gold, &tmp_gold, sizeof(tmp_gold));
  if (raw_gold != 0) {
    _this->_internal_set_gold(from._internal_gold());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_increasepower = from._internal_increasepower();
  ::uint32_t raw_increasepower;
  memcpy(&raw_increasepower, &tmp_increasepower, sizeof(tmp_increasepower));
  if (raw_increasepower != 0) {
    _this->_internal_set_increasepower(from._internal_increasepower());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_increasedefensive = from._internal_increasedefensive();
  ::uint32_t raw_increasedefensive;
  memcpy(&raw_increasedefensive, &tmp_increasedefensive, sizeof(tmp_increasedefensive));
  if (raw_increasedefensive != 0) {
    _this->_internal_set_increasedefensive(from._internal_increasedefensive());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_increasehp = from._internal_increasehp();
  ::uint32_t raw_increasehp;
  memcpy(&raw_increasehp, &tmp_increasehp, sizeof(tmp_increasehp));
  if (raw_increasehp != 0) {
    _this->_internal_set_increasehp(from._internal_increasehp());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void EQINFO::CopyFrom(const EQINFO& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:EQINFO)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool EQINFO::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* EQINFO::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void EQINFO::InternalSwap(EQINFO* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EQINFO, _impl_.increasehp_)
      + sizeof(EQINFO::_impl_.increasehp_)
      - PROTOBUF_FIELD_OFFSET(EQINFO, _impl_.gold_)>(
          reinterpret_cast<char*>(&_impl_.gold_),
          reinterpret_cast<char*>(&other->_impl_.gold_));
}

::google::protobuf::Metadata EQINFO::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[2]);
}
// ===================================================================

class CHARSTATE::_Internal {
 public:
};

CHARSTATE::CHARSTATE(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CHARSTATE)
}
CHARSTATE::CHARSTATE(
    ::google::protobuf::Arena* arena, const CHARSTATE& from)
    : CHARSTATE(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CHARSTATE::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CHARSTATE::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, triggeron_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::triggeron_));
}
CHARSTATE::~CHARSTATE() {
  // @@protoc_insertion_point(destructor:CHARSTATE)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CHARSTATE::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CHARSTATE::Clear() {
// @@protoc_insertion_point(message_clear_start:CHARSTATE)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.triggeron_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.triggeron_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CHARSTATE::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 10, 0, 0, 2> CHARSTATE::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    10, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966272,  // skipmap
    offsetof(decltype(_table_), field_entries),
    10,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CHARSTATE_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // int64 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(CHARSTATE, _impl_.id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.id_)}},
    // float posx = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.posx_)}},
    // float posy = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.posy_)}},
    // float posz = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.posz_)}},
    // float rotatex = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 63, 0, PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.rotatex_)}},
    // float rotatey = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 63, 0, PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.rotatey_)}},
    // float rotatez = 7;
    {::_pbi::TcParser::FastF32S1,
     {61, 63, 0, PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.rotatez_)}},
    // int32 animationIndex = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CHARSTATE, _impl_.animationindex_), 63>(),
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.animationindex_)}},
    // int32 state = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CHARSTATE, _impl_.state_), 63>(),
     {72, 63, 0, PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.state_)}},
    // int32 triggerOn = 10;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CHARSTATE, _impl_.triggeron_), 63>(),
     {80, 63, 0, PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.triggeron_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 id = 1;
    {PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // float posx = 2;
    {PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.posx_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float posy = 3;
    {PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.posy_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float posz = 4;
    {PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.posz_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float rotatex = 5;
    {PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.rotatex_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float rotatey = 6;
    {PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.rotatey_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float rotatez = 7;
    {PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.rotatez_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // int32 animationIndex = 8;
    {PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.animationindex_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 state = 9;
    {PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.state_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 triggerOn = 10;
    {PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.triggeron_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CHARSTATE::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CHARSTATE)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_id(), target);
  }

  // float posx = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posx = this->_internal_posx();
  ::uint32_t raw_posx;
  memcpy(&raw_posx, &tmp_posx, sizeof(tmp_posx));
  if (raw_posx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_posx(), target);
  }

  // float posy = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posy = this->_internal_posy();
  ::uint32_t raw_posy;
  memcpy(&raw_posy, &tmp_posy, sizeof(tmp_posy));
  if (raw_posy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_posy(), target);
  }

  // float posz = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posz = this->_internal_posz();
  ::uint32_t raw_posz;
  memcpy(&raw_posz, &tmp_posz, sizeof(tmp_posz));
  if (raw_posz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_posz(), target);
  }

  // float rotatex = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rotatex = this->_internal_rotatex();
  ::uint32_t raw_rotatex;
  memcpy(&raw_rotatex, &tmp_rotatex, sizeof(tmp_rotatex));
  if (raw_rotatex != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_rotatex(), target);
  }

  // float rotatey = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rotatey = this->_internal_rotatey();
  ::uint32_t raw_rotatey;
  memcpy(&raw_rotatey, &tmp_rotatey, sizeof(tmp_rotatey));
  if (raw_rotatey != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_rotatey(), target);
  }

  // float rotatez = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rotatez = this->_internal_rotatez();
  ::uint32_t raw_rotatez;
  memcpy(&raw_rotatez, &tmp_rotatez, sizeof(tmp_rotatez));
  if (raw_rotatez != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_rotatez(), target);
  }

  // int32 animationIndex = 8;
  if (this->_internal_animationindex() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<8>(
            stream, this->_internal_animationindex(), target);
  }

  // int32 state = 9;
  if (this->_internal_state() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<9>(
            stream, this->_internal_state(), target);
  }

  // int32 triggerOn = 10;
  if (this->_internal_triggeron() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<10>(
            stream, this->_internal_triggeron(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CHARSTATE)
  return target;
}

::size_t CHARSTATE::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CHARSTATE)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  // float posx = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posx = this->_internal_posx();
  ::uint32_t raw_posx;
  memcpy(&raw_posx, &tmp_posx, sizeof(tmp_posx));
  if (raw_posx != 0) {
    total_size += 5;
  }

  // float posy = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posy = this->_internal_posy();
  ::uint32_t raw_posy;
  memcpy(&raw_posy, &tmp_posy, sizeof(tmp_posy));
  if (raw_posy != 0) {
    total_size += 5;
  }

  // float posz = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posz = this->_internal_posz();
  ::uint32_t raw_posz;
  memcpy(&raw_posz, &tmp_posz, sizeof(tmp_posz));
  if (raw_posz != 0) {
    total_size += 5;
  }

  // float rotatex = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rotatex = this->_internal_rotatex();
  ::uint32_t raw_rotatex;
  memcpy(&raw_rotatex, &tmp_rotatex, sizeof(tmp_rotatex));
  if (raw_rotatex != 0) {
    total_size += 5;
  }

  // float rotatey = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rotatey = this->_internal_rotatey();
  ::uint32_t raw_rotatey;
  memcpy(&raw_rotatey, &tmp_rotatey, sizeof(tmp_rotatey));
  if (raw_rotatey != 0) {
    total_size += 5;
  }

  // float rotatez = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rotatez = this->_internal_rotatez();
  ::uint32_t raw_rotatez;
  memcpy(&raw_rotatez, &tmp_rotatez, sizeof(tmp_rotatez));
  if (raw_rotatez != 0) {
    total_size += 5;
  }

  // int32 animationIndex = 8;
  if (this->_internal_animationindex() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_animationindex());
  }

  // int32 state = 9;
  if (this->_internal_state() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_state());
  }

  // int32 triggerOn = 10;
  if (this->_internal_triggeron() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_triggeron());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CHARSTATE::_class_data_ = {
    CHARSTATE::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* CHARSTATE::GetClassData() const {
  return &_class_data_;
}

void CHARSTATE::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CHARSTATE*>(&to_msg);
  auto& from = static_cast<const CHARSTATE&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CHARSTATE)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posx = from._internal_posx();
  ::uint32_t raw_posx;
  memcpy(&raw_posx, &tmp_posx, sizeof(tmp_posx));
  if (raw_posx != 0) {
    _this->_internal_set_posx(from._internal_posx());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posy = from._internal_posy();
  ::uint32_t raw_posy;
  memcpy(&raw_posy, &tmp_posy, sizeof(tmp_posy));
  if (raw_posy != 0) {
    _this->_internal_set_posy(from._internal_posy());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posz = from._internal_posz();
  ::uint32_t raw_posz;
  memcpy(&raw_posz, &tmp_posz, sizeof(tmp_posz));
  if (raw_posz != 0) {
    _this->_internal_set_posz(from._internal_posz());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rotatex = from._internal_rotatex();
  ::uint32_t raw_rotatex;
  memcpy(&raw_rotatex, &tmp_rotatex, sizeof(tmp_rotatex));
  if (raw_rotatex != 0) {
    _this->_internal_set_rotatex(from._internal_rotatex());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rotatey = from._internal_rotatey();
  ::uint32_t raw_rotatey;
  memcpy(&raw_rotatey, &tmp_rotatey, sizeof(tmp_rotatey));
  if (raw_rotatey != 0) {
    _this->_internal_set_rotatey(from._internal_rotatey());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rotatez = from._internal_rotatez();
  ::uint32_t raw_rotatez;
  memcpy(&raw_rotatez, &tmp_rotatez, sizeof(tmp_rotatez));
  if (raw_rotatez != 0) {
    _this->_internal_set_rotatez(from._internal_rotatez());
  }
  if (from._internal_animationindex() != 0) {
    _this->_internal_set_animationindex(from._internal_animationindex());
  }
  if (from._internal_state() != 0) {
    _this->_internal_set_state(from._internal_state());
  }
  if (from._internal_triggeron() != 0) {
    _this->_internal_set_triggeron(from._internal_triggeron());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CHARSTATE::CopyFrom(const CHARSTATE& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CHARSTATE)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CHARSTATE::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* CHARSTATE::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CHARSTATE::InternalSwap(CHARSTATE* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.triggeron_)
      + sizeof(CHARSTATE::_impl_.triggeron_)
      - PROTOBUF_FIELD_OFFSET(CHARSTATE, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::google::protobuf::Metadata CHARSTATE::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[3]);
}
// ===================================================================

class MOBSTATE::_Internal {
 public:
};

MOBSTATE::MOBSTATE(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:MOBSTATE)
}
MOBSTATE::MOBSTATE(
    ::google::protobuf::Arena* arena, const MOBSTATE& from)
    : MOBSTATE(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE MOBSTATE::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void MOBSTATE::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, animtime_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::animtime_));
}
MOBSTATE::~MOBSTATE() {
  // @@protoc_insertion_point(destructor:MOBSTATE)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void MOBSTATE::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void MOBSTATE::Clear() {
// @@protoc_insertion_point(message_clear_start:MOBSTATE)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.animtime_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.animtime_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* MOBSTATE::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 14, 0, 0, 2> MOBSTATE::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    14, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950912,  // skipmap
    offsetof(decltype(_table_), field_entries),
    14,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_MOBSTATE_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // int64 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(MOBSTATE, _impl_.id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.id_)}},
    // float posx = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.posx_)}},
    // float posy = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.posy_)}},
    // float posz = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.posz_)}},
    // float rotatex = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 63, 0, PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.rotatex_)}},
    // float rotatey = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 63, 0, PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.rotatey_)}},
    // float rotatez = 7;
    {::_pbi::TcParser::FastF32S1,
     {61, 63, 0, PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.rotatez_)}},
    // int32 animationIndex = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MOBSTATE, _impl_.animationindex_), 63>(),
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.animationindex_)}},
    // int32 state = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(MOBSTATE, _impl_.state_), 63>(),
     {72, 63, 0, PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.state_)}},
    // bool triggerOn = 10;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(MOBSTATE, _impl_.triggeron_), 63>(),
     {80, 63, 0, PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.triggeron_)}},
    // bool foundOn = 11;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(MOBSTATE, _impl_.foundon_), 63>(),
     {88, 63, 0, PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.foundon_)}},
    // bool damageOn = 12;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(MOBSTATE, _impl_.damageon_), 63>(),
     {96, 63, 0, PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.damageon_)}},
    // bool remain2 = 13;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(MOBSTATE, _impl_.remain2_), 63>(),
     {104, 63, 0, PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.remain2_)}},
    // float animtime = 14;
    {::_pbi::TcParser::FastF32S1,
     {117, 63, 0, PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.animtime_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 id = 1;
    {PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // float posx = 2;
    {PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.posx_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float posy = 3;
    {PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.posy_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float posz = 4;
    {PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.posz_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float rotatex = 5;
    {PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.rotatex_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float rotatey = 6;
    {PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.rotatey_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float rotatez = 7;
    {PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.rotatez_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // int32 animationIndex = 8;
    {PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.animationindex_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 state = 9;
    {PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.state_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // bool triggerOn = 10;
    {PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.triggeron_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool foundOn = 11;
    {PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.foundon_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool damageOn = 12;
    {PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.damageon_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool remain2 = 13;
    {PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.remain2_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // float animtime = 14;
    {PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.animtime_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* MOBSTATE::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:MOBSTATE)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_id(), target);
  }

  // float posx = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posx = this->_internal_posx();
  ::uint32_t raw_posx;
  memcpy(&raw_posx, &tmp_posx, sizeof(tmp_posx));
  if (raw_posx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_posx(), target);
  }

  // float posy = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posy = this->_internal_posy();
  ::uint32_t raw_posy;
  memcpy(&raw_posy, &tmp_posy, sizeof(tmp_posy));
  if (raw_posy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_posy(), target);
  }

  // float posz = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posz = this->_internal_posz();
  ::uint32_t raw_posz;
  memcpy(&raw_posz, &tmp_posz, sizeof(tmp_posz));
  if (raw_posz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_posz(), target);
  }

  // float rotatex = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rotatex = this->_internal_rotatex();
  ::uint32_t raw_rotatex;
  memcpy(&raw_rotatex, &tmp_rotatex, sizeof(tmp_rotatex));
  if (raw_rotatex != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_rotatex(), target);
  }

  // float rotatey = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rotatey = this->_internal_rotatey();
  ::uint32_t raw_rotatey;
  memcpy(&raw_rotatey, &tmp_rotatey, sizeof(tmp_rotatey));
  if (raw_rotatey != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_rotatey(), target);
  }

  // float rotatez = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rotatez = this->_internal_rotatez();
  ::uint32_t raw_rotatez;
  memcpy(&raw_rotatez, &tmp_rotatez, sizeof(tmp_rotatez));
  if (raw_rotatez != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_rotatez(), target);
  }

  // int32 animationIndex = 8;
  if (this->_internal_animationindex() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<8>(
            stream, this->_internal_animationindex(), target);
  }

  // int32 state = 9;
  if (this->_internal_state() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<9>(
            stream, this->_internal_state(), target);
  }

  // bool triggerOn = 10;
  if (this->_internal_triggeron() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        10, this->_internal_triggeron(), target);
  }

  // bool foundOn = 11;
  if (this->_internal_foundon() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        11, this->_internal_foundon(), target);
  }

  // bool damageOn = 12;
  if (this->_internal_damageon() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        12, this->_internal_damageon(), target);
  }

  // bool remain2 = 13;
  if (this->_internal_remain2() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        13, this->_internal_remain2(), target);
  }

  // float animtime = 14;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_animtime = this->_internal_animtime();
  ::uint32_t raw_animtime;
  memcpy(&raw_animtime, &tmp_animtime, sizeof(tmp_animtime));
  if (raw_animtime != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        14, this->_internal_animtime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MOBSTATE)
  return target;
}

::size_t MOBSTATE::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MOBSTATE)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  // float posx = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posx = this->_internal_posx();
  ::uint32_t raw_posx;
  memcpy(&raw_posx, &tmp_posx, sizeof(tmp_posx));
  if (raw_posx != 0) {
    total_size += 5;
  }

  // float posy = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posy = this->_internal_posy();
  ::uint32_t raw_posy;
  memcpy(&raw_posy, &tmp_posy, sizeof(tmp_posy));
  if (raw_posy != 0) {
    total_size += 5;
  }

  // float posz = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posz = this->_internal_posz();
  ::uint32_t raw_posz;
  memcpy(&raw_posz, &tmp_posz, sizeof(tmp_posz));
  if (raw_posz != 0) {
    total_size += 5;
  }

  // float rotatex = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rotatex = this->_internal_rotatex();
  ::uint32_t raw_rotatex;
  memcpy(&raw_rotatex, &tmp_rotatex, sizeof(tmp_rotatex));
  if (raw_rotatex != 0) {
    total_size += 5;
  }

  // float rotatey = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rotatey = this->_internal_rotatey();
  ::uint32_t raw_rotatey;
  memcpy(&raw_rotatey, &tmp_rotatey, sizeof(tmp_rotatey));
  if (raw_rotatey != 0) {
    total_size += 5;
  }

  // float rotatez = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rotatez = this->_internal_rotatez();
  ::uint32_t raw_rotatez;
  memcpy(&raw_rotatez, &tmp_rotatez, sizeof(tmp_rotatez));
  if (raw_rotatez != 0) {
    total_size += 5;
  }

  // int32 animationIndex = 8;
  if (this->_internal_animationindex() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_animationindex());
  }

  // int32 state = 9;
  if (this->_internal_state() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_state());
  }

  // bool triggerOn = 10;
  if (this->_internal_triggeron() != 0) {
    total_size += 2;
  }

  // bool foundOn = 11;
  if (this->_internal_foundon() != 0) {
    total_size += 2;
  }

  // bool damageOn = 12;
  if (this->_internal_damageon() != 0) {
    total_size += 2;
  }

  // bool remain2 = 13;
  if (this->_internal_remain2() != 0) {
    total_size += 2;
  }

  // float animtime = 14;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_animtime = this->_internal_animtime();
  ::uint32_t raw_animtime;
  memcpy(&raw_animtime, &tmp_animtime, sizeof(tmp_animtime));
  if (raw_animtime != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData MOBSTATE::_class_data_ = {
    MOBSTATE::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* MOBSTATE::GetClassData() const {
  return &_class_data_;
}

void MOBSTATE::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<MOBSTATE*>(&to_msg);
  auto& from = static_cast<const MOBSTATE&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:MOBSTATE)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posx = from._internal_posx();
  ::uint32_t raw_posx;
  memcpy(&raw_posx, &tmp_posx, sizeof(tmp_posx));
  if (raw_posx != 0) {
    _this->_internal_set_posx(from._internal_posx());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posy = from._internal_posy();
  ::uint32_t raw_posy;
  memcpy(&raw_posy, &tmp_posy, sizeof(tmp_posy));
  if (raw_posy != 0) {
    _this->_internal_set_posy(from._internal_posy());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posz = from._internal_posz();
  ::uint32_t raw_posz;
  memcpy(&raw_posz, &tmp_posz, sizeof(tmp_posz));
  if (raw_posz != 0) {
    _this->_internal_set_posz(from._internal_posz());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rotatex = from._internal_rotatex();
  ::uint32_t raw_rotatex;
  memcpy(&raw_rotatex, &tmp_rotatex, sizeof(tmp_rotatex));
  if (raw_rotatex != 0) {
    _this->_internal_set_rotatex(from._internal_rotatex());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rotatey = from._internal_rotatey();
  ::uint32_t raw_rotatey;
  memcpy(&raw_rotatey, &tmp_rotatey, sizeof(tmp_rotatey));
  if (raw_rotatey != 0) {
    _this->_internal_set_rotatey(from._internal_rotatey());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_rotatez = from._internal_rotatez();
  ::uint32_t raw_rotatez;
  memcpy(&raw_rotatez, &tmp_rotatez, sizeof(tmp_rotatez));
  if (raw_rotatez != 0) {
    _this->_internal_set_rotatez(from._internal_rotatez());
  }
  if (from._internal_animationindex() != 0) {
    _this->_internal_set_animationindex(from._internal_animationindex());
  }
  if (from._internal_state() != 0) {
    _this->_internal_set_state(from._internal_state());
  }
  if (from._internal_triggeron() != 0) {
    _this->_internal_set_triggeron(from._internal_triggeron());
  }
  if (from._internal_foundon() != 0) {
    _this->_internal_set_foundon(from._internal_foundon());
  }
  if (from._internal_damageon() != 0) {
    _this->_internal_set_damageon(from._internal_damageon());
  }
  if (from._internal_remain2() != 0) {
    _this->_internal_set_remain2(from._internal_remain2());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_animtime = from._internal_animtime();
  ::uint32_t raw_animtime;
  memcpy(&raw_animtime, &tmp_animtime, sizeof(tmp_animtime));
  if (raw_animtime != 0) {
    _this->_internal_set_animtime(from._internal_animtime());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MOBSTATE::CopyFrom(const MOBSTATE& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MOBSTATE)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool MOBSTATE::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* MOBSTATE::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void MOBSTATE::InternalSwap(MOBSTATE* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.animtime_)
      + sizeof(MOBSTATE::_impl_.animtime_)
      - PROTOBUF_FIELD_OFFSET(MOBSTATE, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::google::protobuf::Metadata MOBSTATE::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[4]);
}
// ===================================================================

class COLLISIONDATA::_Internal {
 public:
};

COLLISIONDATA::COLLISIONDATA(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:COLLISIONDATA)
}
COLLISIONDATA::COLLISIONDATA(
    ::google::protobuf::Arena* arena, const COLLISIONDATA& from)
    : COLLISIONDATA(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE COLLISIONDATA::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void COLLISIONDATA::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, enemyid_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::enemyid_));
}
COLLISIONDATA::~COLLISIONDATA() {
  // @@protoc_insertion_point(destructor:COLLISIONDATA)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void COLLISIONDATA::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void COLLISIONDATA::Clear() {
// @@protoc_insertion_point(message_clear_start:COLLISIONDATA)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.enemyid_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.enemyid_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* COLLISIONDATA::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> COLLISIONDATA::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_COLLISIONDATA_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // int64 enemyID = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(COLLISIONDATA, _impl_.enemyid_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(COLLISIONDATA, _impl_.enemyid_)}},
    // int64 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(COLLISIONDATA, _impl_.id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(COLLISIONDATA, _impl_.id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 id = 1;
    {PROTOBUF_FIELD_OFFSET(COLLISIONDATA, _impl_.id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // int64 enemyID = 2;
    {PROTOBUF_FIELD_OFFSET(COLLISIONDATA, _impl_.enemyid_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* COLLISIONDATA::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:COLLISIONDATA)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_id(), target);
  }

  // int64 enemyID = 2;
  if (this->_internal_enemyid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<2>(
            stream, this->_internal_enemyid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:COLLISIONDATA)
  return target;
}

::size_t COLLISIONDATA::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:COLLISIONDATA)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  // int64 enemyID = 2;
  if (this->_internal_enemyid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_enemyid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData COLLISIONDATA::_class_data_ = {
    COLLISIONDATA::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* COLLISIONDATA::GetClassData() const {
  return &_class_data_;
}

void COLLISIONDATA::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<COLLISIONDATA*>(&to_msg);
  auto& from = static_cast<const COLLISIONDATA&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:COLLISIONDATA)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_enemyid() != 0) {
    _this->_internal_set_enemyid(from._internal_enemyid());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void COLLISIONDATA::CopyFrom(const COLLISIONDATA& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:COLLISIONDATA)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool COLLISIONDATA::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* COLLISIONDATA::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void COLLISIONDATA::InternalSwap(COLLISIONDATA* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(COLLISIONDATA, _impl_.enemyid_)
      + sizeof(COLLISIONDATA::_impl_.enemyid_)
      - PROTOBUF_FIELD_OFFSET(COLLISIONDATA, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::google::protobuf::Metadata COLLISIONDATA::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[5]);
}
// ===================================================================

class SC_CONNECTSUCCESS::_Internal {
 public:
};

SC_CONNECTSUCCESS::SC_CONNECTSUCCESS(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:SC_CONNECTSUCCESS)
}
SC_CONNECTSUCCESS::SC_CONNECTSUCCESS(
    ::google::protobuf::Arena* arena, const SC_CONNECTSUCCESS& from)
    : SC_CONNECTSUCCESS(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE SC_CONNECTSUCCESS::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void SC_CONNECTSUCCESS::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, type_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::type_));
}
SC_CONNECTSUCCESS::~SC_CONNECTSUCCESS() {
  // @@protoc_insertion_point(destructor:SC_CONNECTSUCCESS)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SC_CONNECTSUCCESS::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void SC_CONNECTSUCCESS::Clear() {
// @@protoc_insertion_point(message_clear_start:SC_CONNECTSUCCESS)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.type_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SC_CONNECTSUCCESS::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> SC_CONNECTSUCCESS::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967284,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SC_CONNECTSUCCESS_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // int32 type = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(SC_CONNECTSUCCESS, _impl_.type_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(SC_CONNECTSUCCESS, _impl_.type_)}},
    // int64 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(SC_CONNECTSUCCESS, _impl_.id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(SC_CONNECTSUCCESS, _impl_.id_)}},
    // int32 cellIndex = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(SC_CONNECTSUCCESS, _impl_.cellindex_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(SC_CONNECTSUCCESS, _impl_.cellindex_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 id = 1;
    {PROTOBUF_FIELD_OFFSET(SC_CONNECTSUCCESS, _impl_.id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // int32 cellIndex = 2;
    {PROTOBUF_FIELD_OFFSET(SC_CONNECTSUCCESS, _impl_.cellindex_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 type = 4;
    {PROTOBUF_FIELD_OFFSET(SC_CONNECTSUCCESS, _impl_.type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* SC_CONNECTSUCCESS::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC_CONNECTSUCCESS)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_id(), target);
  }

  // int32 cellIndex = 2;
  if (this->_internal_cellindex() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<2>(
            stream, this->_internal_cellindex(), target);
  }

  // int32 type = 4;
  if (this->_internal_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<4>(
            stream, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC_CONNECTSUCCESS)
  return target;
}

::size_t SC_CONNECTSUCCESS::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC_CONNECTSUCCESS)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  // int32 cellIndex = 2;
  if (this->_internal_cellindex() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_cellindex());
  }

  // int32 type = 4;
  if (this->_internal_type() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SC_CONNECTSUCCESS::_class_data_ = {
    SC_CONNECTSUCCESS::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* SC_CONNECTSUCCESS::GetClassData() const {
  return &_class_data_;
}

void SC_CONNECTSUCCESS::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SC_CONNECTSUCCESS*>(&to_msg);
  auto& from = static_cast<const SC_CONNECTSUCCESS&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC_CONNECTSUCCESS)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_cellindex() != 0) {
    _this->_internal_set_cellindex(from._internal_cellindex());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SC_CONNECTSUCCESS::CopyFrom(const SC_CONNECTSUCCESS& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC_CONNECTSUCCESS)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SC_CONNECTSUCCESS::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* SC_CONNECTSUCCESS::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void SC_CONNECTSUCCESS::InternalSwap(SC_CONNECTSUCCESS* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SC_CONNECTSUCCESS, _impl_.type_)
      + sizeof(SC_CONNECTSUCCESS::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(SC_CONNECTSUCCESS, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::google::protobuf::Metadata SC_CONNECTSUCCESS::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[6]);
}
// ===================================================================

class SC_OTHERCLIENTLOGIN::_Internal {
 public:
};

SC_OTHERCLIENTLOGIN::SC_OTHERCLIENTLOGIN(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:SC_OTHERCLIENTLOGIN)
}
SC_OTHERCLIENTLOGIN::SC_OTHERCLIENTLOGIN(
    ::google::protobuf::Arena* arena, const SC_OTHERCLIENTLOGIN& from)
    : SC_OTHERCLIENTLOGIN(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE SC_OTHERCLIENTLOGIN::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void SC_OTHERCLIENTLOGIN::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, type_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::type_));
}
SC_OTHERCLIENTLOGIN::~SC_OTHERCLIENTLOGIN() {
  // @@protoc_insertion_point(destructor:SC_OTHERCLIENTLOGIN)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SC_OTHERCLIENTLOGIN::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void SC_OTHERCLIENTLOGIN::Clear() {
// @@protoc_insertion_point(message_clear_start:SC_OTHERCLIENTLOGIN)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.type_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.type_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SC_OTHERCLIENTLOGIN::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> SC_OTHERCLIENTLOGIN::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SC_OTHERCLIENTLOGIN_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // int64 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(SC_OTHERCLIENTLOGIN, _impl_.id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(SC_OTHERCLIENTLOGIN, _impl_.id_)}},
    // int32 cellIndex = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(SC_OTHERCLIENTLOGIN, _impl_.cellindex_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(SC_OTHERCLIENTLOGIN, _impl_.cellindex_)}},
    // int32 type = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(SC_OTHERCLIENTLOGIN, _impl_.type_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(SC_OTHERCLIENTLOGIN, _impl_.type_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 id = 1;
    {PROTOBUF_FIELD_OFFSET(SC_OTHERCLIENTLOGIN, _impl_.id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // int32 cellIndex = 2;
    {PROTOBUF_FIELD_OFFSET(SC_OTHERCLIENTLOGIN, _impl_.cellindex_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 type = 3;
    {PROTOBUF_FIELD_OFFSET(SC_OTHERCLIENTLOGIN, _impl_.type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* SC_OTHERCLIENTLOGIN::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC_OTHERCLIENTLOGIN)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_id(), target);
  }

  // int32 cellIndex = 2;
  if (this->_internal_cellindex() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<2>(
            stream, this->_internal_cellindex(), target);
  }

  // int32 type = 3;
  if (this->_internal_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC_OTHERCLIENTLOGIN)
  return target;
}

::size_t SC_OTHERCLIENTLOGIN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC_OTHERCLIENTLOGIN)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  // int32 cellIndex = 2;
  if (this->_internal_cellindex() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_cellindex());
  }

  // int32 type = 3;
  if (this->_internal_type() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SC_OTHERCLIENTLOGIN::_class_data_ = {
    SC_OTHERCLIENTLOGIN::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* SC_OTHERCLIENTLOGIN::GetClassData() const {
  return &_class_data_;
}

void SC_OTHERCLIENTLOGIN::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SC_OTHERCLIENTLOGIN*>(&to_msg);
  auto& from = static_cast<const SC_OTHERCLIENTLOGIN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC_OTHERCLIENTLOGIN)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_cellindex() != 0) {
    _this->_internal_set_cellindex(from._internal_cellindex());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SC_OTHERCLIENTLOGIN::CopyFrom(const SC_OTHERCLIENTLOGIN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC_OTHERCLIENTLOGIN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SC_OTHERCLIENTLOGIN::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* SC_OTHERCLIENTLOGIN::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void SC_OTHERCLIENTLOGIN::InternalSwap(SC_OTHERCLIENTLOGIN* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SC_OTHERCLIENTLOGIN, _impl_.type_)
      + sizeof(SC_OTHERCLIENTLOGIN::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(SC_OTHERCLIENTLOGIN, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::google::protobuf::Metadata SC_OTHERCLIENTLOGIN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[7]);
}
// ===================================================================

class SC_MONSTERFIND::_Internal {
 public:
};

SC_MONSTERFIND::SC_MONSTERFIND(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:SC_MONSTERFIND)
}
SC_MONSTERFIND::SC_MONSTERFIND(
    ::google::protobuf::Arena* arena, const SC_MONSTERFIND& from)
    : SC_MONSTERFIND(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE SC_MONSTERFIND::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void SC_MONSTERFIND::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, targetid_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::targetid_));
}
SC_MONSTERFIND::~SC_MONSTERFIND() {
  // @@protoc_insertion_point(destructor:SC_MONSTERFIND)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SC_MONSTERFIND::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void SC_MONSTERFIND::Clear() {
// @@protoc_insertion_point(message_clear_start:SC_MONSTERFIND)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.targetid_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.targetid_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SC_MONSTERFIND::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> SC_MONSTERFIND::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SC_MONSTERFIND_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // int32 targetID = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(SC_MONSTERFIND, _impl_.targetid_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(SC_MONSTERFIND, _impl_.targetid_)}},
    // int64 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(SC_MONSTERFIND, _impl_.id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(SC_MONSTERFIND, _impl_.id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 id = 1;
    {PROTOBUF_FIELD_OFFSET(SC_MONSTERFIND, _impl_.id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // int32 targetID = 2;
    {PROTOBUF_FIELD_OFFSET(SC_MONSTERFIND, _impl_.targetid_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* SC_MONSTERFIND::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC_MONSTERFIND)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_id(), target);
  }

  // int32 targetID = 2;
  if (this->_internal_targetid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<2>(
            stream, this->_internal_targetid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC_MONSTERFIND)
  return target;
}

::size_t SC_MONSTERFIND::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC_MONSTERFIND)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  // int32 targetID = 2;
  if (this->_internal_targetid() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_targetid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SC_MONSTERFIND::_class_data_ = {
    SC_MONSTERFIND::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* SC_MONSTERFIND::GetClassData() const {
  return &_class_data_;
}

void SC_MONSTERFIND::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SC_MONSTERFIND*>(&to_msg);
  auto& from = static_cast<const SC_MONSTERFIND&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC_MONSTERFIND)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_targetid() != 0) {
    _this->_internal_set_targetid(from._internal_targetid());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SC_MONSTERFIND::CopyFrom(const SC_MONSTERFIND& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC_MONSTERFIND)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SC_MONSTERFIND::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* SC_MONSTERFIND::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void SC_MONSTERFIND::InternalSwap(SC_MONSTERFIND* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SC_MONSTERFIND, _impl_.targetid_)
      + sizeof(SC_MONSTERFIND::_impl_.targetid_)
      - PROTOBUF_FIELD_OFFSET(SC_MONSTERFIND, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::google::protobuf::Metadata SC_MONSTERFIND::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[8]);
}
// ===================================================================

class SC_DAMAGED::_Internal {
 public:
};

SC_DAMAGED::SC_DAMAGED(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:SC_DAMAGED)
}
SC_DAMAGED::SC_DAMAGED(
    ::google::protobuf::Arena* arena, const SC_DAMAGED& from)
    : SC_DAMAGED(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE SC_DAMAGED::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void SC_DAMAGED::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, hp_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::hp_));
}
SC_DAMAGED::~SC_DAMAGED() {
  // @@protoc_insertion_point(destructor:SC_DAMAGED)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SC_DAMAGED::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void SC_DAMAGED::Clear() {
// @@protoc_insertion_point(message_clear_start:SC_DAMAGED)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.hp_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.hp_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SC_DAMAGED::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> SC_DAMAGED::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SC_DAMAGED_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // float hp = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(SC_DAMAGED, _impl_.hp_)}},
    // int64 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(SC_DAMAGED, _impl_.id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(SC_DAMAGED, _impl_.id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 id = 1;
    {PROTOBUF_FIELD_OFFSET(SC_DAMAGED, _impl_.id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // float hp = 2;
    {PROTOBUF_FIELD_OFFSET(SC_DAMAGED, _impl_.hp_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* SC_DAMAGED::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC_DAMAGED)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_id(), target);
  }

  // float hp = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_hp = this->_internal_hp();
  ::uint32_t raw_hp;
  memcpy(&raw_hp, &tmp_hp, sizeof(tmp_hp));
  if (raw_hp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_hp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC_DAMAGED)
  return target;
}

::size_t SC_DAMAGED::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC_DAMAGED)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  // float hp = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_hp = this->_internal_hp();
  ::uint32_t raw_hp;
  memcpy(&raw_hp, &tmp_hp, sizeof(tmp_hp));
  if (raw_hp != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SC_DAMAGED::_class_data_ = {
    SC_DAMAGED::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* SC_DAMAGED::GetClassData() const {
  return &_class_data_;
}

void SC_DAMAGED::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SC_DAMAGED*>(&to_msg);
  auto& from = static_cast<const SC_DAMAGED&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC_DAMAGED)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_hp = from._internal_hp();
  ::uint32_t raw_hp;
  memcpy(&raw_hp, &tmp_hp, sizeof(tmp_hp));
  if (raw_hp != 0) {
    _this->_internal_set_hp(from._internal_hp());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SC_DAMAGED::CopyFrom(const SC_DAMAGED& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC_DAMAGED)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SC_DAMAGED::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* SC_DAMAGED::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void SC_DAMAGED::InternalSwap(SC_DAMAGED* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SC_DAMAGED, _impl_.hp_)
      + sizeof(SC_DAMAGED::_impl_.hp_)
      - PROTOBUF_FIELD_OFFSET(SC_DAMAGED, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::google::protobuf::Metadata SC_DAMAGED::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[9]);
}
// ===================================================================

class SC_SEEPLAYERMOVE::_Internal {
 public:
};

SC_SEEPLAYERMOVE::SC_SEEPLAYERMOVE(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:SC_SEEPLAYERMOVE)
}
SC_SEEPLAYERMOVE::SC_SEEPLAYERMOVE(
    ::google::protobuf::Arena* arena, const SC_SEEPLAYERMOVE& from)
    : SC_SEEPLAYERMOVE(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE SC_SEEPLAYERMOVE::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void SC_SEEPLAYERMOVE::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, posz_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::posz_));
}
SC_SEEPLAYERMOVE::~SC_SEEPLAYERMOVE() {
  // @@protoc_insertion_point(destructor:SC_SEEPLAYERMOVE)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SC_SEEPLAYERMOVE::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void SC_SEEPLAYERMOVE::Clear() {
// @@protoc_insertion_point(message_clear_start:SC_SEEPLAYERMOVE)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.posz_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.posz_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SC_SEEPLAYERMOVE::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> SC_SEEPLAYERMOVE::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SC_SEEPLAYERMOVE_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // float posZ = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(SC_SEEPLAYERMOVE, _impl_.posz_)}},
    // int64 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(SC_SEEPLAYERMOVE, _impl_.id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(SC_SEEPLAYERMOVE, _impl_.id_)}},
    // float posX = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(SC_SEEPLAYERMOVE, _impl_.posx_)}},
    // float posY = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(SC_SEEPLAYERMOVE, _impl_.posy_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 id = 1;
    {PROTOBUF_FIELD_OFFSET(SC_SEEPLAYERMOVE, _impl_.id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // float posX = 2;
    {PROTOBUF_FIELD_OFFSET(SC_SEEPLAYERMOVE, _impl_.posx_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float posY = 3;
    {PROTOBUF_FIELD_OFFSET(SC_SEEPLAYERMOVE, _impl_.posy_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float posZ = 4;
    {PROTOBUF_FIELD_OFFSET(SC_SEEPLAYERMOVE, _impl_.posz_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* SC_SEEPLAYERMOVE::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC_SEEPLAYERMOVE)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_id(), target);
  }

  // float posX = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posx = this->_internal_posx();
  ::uint32_t raw_posx;
  memcpy(&raw_posx, &tmp_posx, sizeof(tmp_posx));
  if (raw_posx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_posx(), target);
  }

  // float posY = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posy = this->_internal_posy();
  ::uint32_t raw_posy;
  memcpy(&raw_posy, &tmp_posy, sizeof(tmp_posy));
  if (raw_posy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_posy(), target);
  }

  // float posZ = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posz = this->_internal_posz();
  ::uint32_t raw_posz;
  memcpy(&raw_posz, &tmp_posz, sizeof(tmp_posz));
  if (raw_posz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_posz(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC_SEEPLAYERMOVE)
  return target;
}

::size_t SC_SEEPLAYERMOVE::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC_SEEPLAYERMOVE)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  // float posX = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posx = this->_internal_posx();
  ::uint32_t raw_posx;
  memcpy(&raw_posx, &tmp_posx, sizeof(tmp_posx));
  if (raw_posx != 0) {
    total_size += 5;
  }

  // float posY = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posy = this->_internal_posy();
  ::uint32_t raw_posy;
  memcpy(&raw_posy, &tmp_posy, sizeof(tmp_posy));
  if (raw_posy != 0) {
    total_size += 5;
  }

  // float posZ = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posz = this->_internal_posz();
  ::uint32_t raw_posz;
  memcpy(&raw_posz, &tmp_posz, sizeof(tmp_posz));
  if (raw_posz != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SC_SEEPLAYERMOVE::_class_data_ = {
    SC_SEEPLAYERMOVE::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* SC_SEEPLAYERMOVE::GetClassData() const {
  return &_class_data_;
}

void SC_SEEPLAYERMOVE::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SC_SEEPLAYERMOVE*>(&to_msg);
  auto& from = static_cast<const SC_SEEPLAYERMOVE&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC_SEEPLAYERMOVE)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posx = from._internal_posx();
  ::uint32_t raw_posx;
  memcpy(&raw_posx, &tmp_posx, sizeof(tmp_posx));
  if (raw_posx != 0) {
    _this->_internal_set_posx(from._internal_posx());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posy = from._internal_posy();
  ::uint32_t raw_posy;
  memcpy(&raw_posy, &tmp_posy, sizeof(tmp_posy));
  if (raw_posy != 0) {
    _this->_internal_set_posy(from._internal_posy());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posz = from._internal_posz();
  ::uint32_t raw_posz;
  memcpy(&raw_posz, &tmp_posz, sizeof(tmp_posz));
  if (raw_posz != 0) {
    _this->_internal_set_posz(from._internal_posz());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SC_SEEPLAYERMOVE::CopyFrom(const SC_SEEPLAYERMOVE& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC_SEEPLAYERMOVE)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SC_SEEPLAYERMOVE::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* SC_SEEPLAYERMOVE::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void SC_SEEPLAYERMOVE::InternalSwap(SC_SEEPLAYERMOVE* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SC_SEEPLAYERMOVE, _impl_.posz_)
      + sizeof(SC_SEEPLAYERMOVE::_impl_.posz_)
      - PROTOBUF_FIELD_OFFSET(SC_SEEPLAYERMOVE, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::google::protobuf::Metadata SC_SEEPLAYERMOVE::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[10]);
}
// ===================================================================

class SC_STATICOBJFIND::_Internal {
 public:
};

SC_STATICOBJFIND::SC_STATICOBJFIND(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:SC_STATICOBJFIND)
}
SC_STATICOBJFIND::SC_STATICOBJFIND(
    ::google::protobuf::Arena* arena, const SC_STATICOBJFIND& from)
    : SC_STATICOBJFIND(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE SC_STATICOBJFIND::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void SC_STATICOBJFIND::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, enable_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::enable_));
}
SC_STATICOBJFIND::~SC_STATICOBJFIND() {
  // @@protoc_insertion_point(destructor:SC_STATICOBJFIND)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SC_STATICOBJFIND::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void SC_STATICOBJFIND::Clear() {
// @@protoc_insertion_point(message_clear_start:SC_STATICOBJFIND)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.enable_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.enable_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SC_STATICOBJFIND::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> SC_STATICOBJFIND::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SC_STATICOBJFIND_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // int32 enable = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(SC_STATICOBJFIND, _impl_.enable_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(SC_STATICOBJFIND, _impl_.enable_)}},
    // int64 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(SC_STATICOBJFIND, _impl_.id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(SC_STATICOBJFIND, _impl_.id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 id = 1;
    {PROTOBUF_FIELD_OFFSET(SC_STATICOBJFIND, _impl_.id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // int32 enable = 2;
    {PROTOBUF_FIELD_OFFSET(SC_STATICOBJFIND, _impl_.enable_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* SC_STATICOBJFIND::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC_STATICOBJFIND)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_id(), target);
  }

  // int32 enable = 2;
  if (this->_internal_enable() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<2>(
            stream, this->_internal_enable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC_STATICOBJFIND)
  return target;
}

::size_t SC_STATICOBJFIND::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC_STATICOBJFIND)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  // int32 enable = 2;
  if (this->_internal_enable() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_enable());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SC_STATICOBJFIND::_class_data_ = {
    SC_STATICOBJFIND::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* SC_STATICOBJFIND::GetClassData() const {
  return &_class_data_;
}

void SC_STATICOBJFIND::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SC_STATICOBJFIND*>(&to_msg);
  auto& from = static_cast<const SC_STATICOBJFIND&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC_STATICOBJFIND)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_enable() != 0) {
    _this->_internal_set_enable(from._internal_enable());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SC_STATICOBJFIND::CopyFrom(const SC_STATICOBJFIND& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC_STATICOBJFIND)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SC_STATICOBJFIND::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* SC_STATICOBJFIND::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void SC_STATICOBJFIND::InternalSwap(SC_STATICOBJFIND* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SC_STATICOBJFIND, _impl_.enable_)
      + sizeof(SC_STATICOBJFIND::_impl_.enable_)
      - PROTOBUF_FIELD_OFFSET(SC_STATICOBJFIND, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::google::protobuf::Metadata SC_STATICOBJFIND::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[11]);
}
// ===================================================================

class SC_HARLEQUINTHROWING::_Internal {
 public:
};

SC_HARLEQUINTHROWING::SC_HARLEQUINTHROWING(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:SC_HARLEQUINTHROWING)
}
SC_HARLEQUINTHROWING::SC_HARLEQUINTHROWING(
    ::google::protobuf::Arena* arena, const SC_HARLEQUINTHROWING& from)
    : SC_HARLEQUINTHROWING(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE SC_HARLEQUINTHROWING::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void SC_HARLEQUINTHROWING::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, posz_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::posz_));
}
SC_HARLEQUINTHROWING::~SC_HARLEQUINTHROWING() {
  // @@protoc_insertion_point(destructor:SC_HARLEQUINTHROWING)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SC_HARLEQUINTHROWING::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void SC_HARLEQUINTHROWING::Clear() {
// @@protoc_insertion_point(message_clear_start:SC_HARLEQUINTHROWING)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.posz_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.posz_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SC_HARLEQUINTHROWING::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> SC_HARLEQUINTHROWING::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SC_HARLEQUINTHROWING_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // float posZ = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(SC_HARLEQUINTHROWING, _impl_.posz_)}},
    // int32 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(SC_HARLEQUINTHROWING, _impl_.id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(SC_HARLEQUINTHROWING, _impl_.id_)}},
    // float posX = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(SC_HARLEQUINTHROWING, _impl_.posx_)}},
    // float posY = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(SC_HARLEQUINTHROWING, _impl_.posy_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int32 id = 1;
    {PROTOBUF_FIELD_OFFSET(SC_HARLEQUINTHROWING, _impl_.id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // float posX = 2;
    {PROTOBUF_FIELD_OFFSET(SC_HARLEQUINTHROWING, _impl_.posx_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float posY = 3;
    {PROTOBUF_FIELD_OFFSET(SC_HARLEQUINTHROWING, _impl_.posy_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float posZ = 4;
    {PROTOBUF_FIELD_OFFSET(SC_HARLEQUINTHROWING, _impl_.posz_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* SC_HARLEQUINTHROWING::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SC_HARLEQUINTHROWING)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<1>(
            stream, this->_internal_id(), target);
  }

  // float posX = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posx = this->_internal_posx();
  ::uint32_t raw_posx;
  memcpy(&raw_posx, &tmp_posx, sizeof(tmp_posx));
  if (raw_posx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_posx(), target);
  }

  // float posY = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posy = this->_internal_posy();
  ::uint32_t raw_posy;
  memcpy(&raw_posy, &tmp_posy, sizeof(tmp_posy));
  if (raw_posy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_posy(), target);
  }

  // float posZ = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posz = this->_internal_posz();
  ::uint32_t raw_posz;
  memcpy(&raw_posz, &tmp_posz, sizeof(tmp_posz));
  if (raw_posz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_posz(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SC_HARLEQUINTHROWING)
  return target;
}

::size_t SC_HARLEQUINTHROWING::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SC_HARLEQUINTHROWING)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_id());
  }

  // float posX = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posx = this->_internal_posx();
  ::uint32_t raw_posx;
  memcpy(&raw_posx, &tmp_posx, sizeof(tmp_posx));
  if (raw_posx != 0) {
    total_size += 5;
  }

  // float posY = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posy = this->_internal_posy();
  ::uint32_t raw_posy;
  memcpy(&raw_posy, &tmp_posy, sizeof(tmp_posy));
  if (raw_posy != 0) {
    total_size += 5;
  }

  // float posZ = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posz = this->_internal_posz();
  ::uint32_t raw_posz;
  memcpy(&raw_posz, &tmp_posz, sizeof(tmp_posz));
  if (raw_posz != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SC_HARLEQUINTHROWING::_class_data_ = {
    SC_HARLEQUINTHROWING::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* SC_HARLEQUINTHROWING::GetClassData() const {
  return &_class_data_;
}

void SC_HARLEQUINTHROWING::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SC_HARLEQUINTHROWING*>(&to_msg);
  auto& from = static_cast<const SC_HARLEQUINTHROWING&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SC_HARLEQUINTHROWING)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posx = from._internal_posx();
  ::uint32_t raw_posx;
  memcpy(&raw_posx, &tmp_posx, sizeof(tmp_posx));
  if (raw_posx != 0) {
    _this->_internal_set_posx(from._internal_posx());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posy = from._internal_posy();
  ::uint32_t raw_posy;
  memcpy(&raw_posy, &tmp_posy, sizeof(tmp_posy));
  if (raw_posy != 0) {
    _this->_internal_set_posy(from._internal_posy());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_posz = from._internal_posz();
  ::uint32_t raw_posz;
  memcpy(&raw_posz, &tmp_posz, sizeof(tmp_posz));
  if (raw_posz != 0) {
    _this->_internal_set_posz(from._internal_posz());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SC_HARLEQUINTHROWING::CopyFrom(const SC_HARLEQUINTHROWING& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SC_HARLEQUINTHROWING)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SC_HARLEQUINTHROWING::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* SC_HARLEQUINTHROWING::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void SC_HARLEQUINTHROWING::InternalSwap(SC_HARLEQUINTHROWING* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SC_HARLEQUINTHROWING, _impl_.posz_)
      + sizeof(SC_HARLEQUINTHROWING::_impl_.posz_)
      - PROTOBUF_FIELD_OFFSET(SC_HARLEQUINTHROWING, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::google::protobuf::Metadata SC_HARLEQUINTHROWING::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[12]);
}
// ===================================================================

class CS_LOGIN::_Internal {
 public:
};

CS_LOGIN::CS_LOGIN(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CS_LOGIN)
}
CS_LOGIN::CS_LOGIN(
    ::google::protobuf::Arena* arena, const CS_LOGIN& from)
    : CS_LOGIN(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CS_LOGIN::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CS_LOGIN::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.id_ = {};
}
CS_LOGIN::~CS_LOGIN() {
  // @@protoc_insertion_point(destructor:CS_LOGIN)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CS_LOGIN::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CS_LOGIN::Clear() {
// @@protoc_insertion_point(message_clear_start:CS_LOGIN)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = ::int64_t{0};
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CS_LOGIN::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> CS_LOGIN::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CS_LOGIN_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // int64 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(CS_LOGIN, _impl_.id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(CS_LOGIN, _impl_.id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 id = 1;
    {PROTOBUF_FIELD_OFFSET(CS_LOGIN, _impl_.id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CS_LOGIN::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CS_LOGIN)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CS_LOGIN)
  return target;
}

::size_t CS_LOGIN::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CS_LOGIN)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CS_LOGIN::_class_data_ = {
    CS_LOGIN::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* CS_LOGIN::GetClassData() const {
  return &_class_data_;
}

void CS_LOGIN::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CS_LOGIN*>(&to_msg);
  auto& from = static_cast<const CS_LOGIN&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CS_LOGIN)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CS_LOGIN::CopyFrom(const CS_LOGIN& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CS_LOGIN)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CS_LOGIN::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* CS_LOGIN::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CS_LOGIN::InternalSwap(CS_LOGIN* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
        swap(_impl_.id_, other->_impl_.id_);
}

::google::protobuf::Metadata CS_LOGIN::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[13]);
}
// ===================================================================

class CS_ATTACK::_Internal {
 public:
  using HasBits = decltype(std::declval<CS_ATTACK>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CS_ATTACK, _impl_._has_bits_);
  static const ::VECTOR3& attackpos(const CS_ATTACK* msg);
  static void set_has_attackpos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::VECTOR3& CS_ATTACK::_Internal::attackpos(const CS_ATTACK* msg) {
  return *msg->_impl_.attackpos_;
}
CS_ATTACK::CS_ATTACK(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CS_ATTACK)
}
inline PROTOBUF_NDEBUG_INLINE CS_ATTACK::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

CS_ATTACK::CS_ATTACK(
    ::google::protobuf::Arena* arena,
    const CS_ATTACK& from)
    : ::google::protobuf::Message(arena) {
  CS_ATTACK* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.attackpos_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::VECTOR3>(arena, *from._impl_.attackpos_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, id_),
           offsetof(Impl_, damage_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::damage_));

  // @@protoc_insertion_point(copy_constructor:CS_ATTACK)
}
inline PROTOBUF_NDEBUG_INLINE CS_ATTACK::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CS_ATTACK::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, attackpos_),
           0,
           offsetof(Impl_, damage_) -
               offsetof(Impl_, attackpos_) +
               sizeof(Impl_::damage_));
}
CS_ATTACK::~CS_ATTACK() {
  // @@protoc_insertion_point(destructor:CS_ATTACK)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CS_ATTACK::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.attackpos_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CS_ATTACK::Clear() {
// @@protoc_insertion_point(message_clear_start:CS_ATTACK)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.attackpos_ != nullptr);
    _impl_.attackpos_->Clear();
  }
  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.damage_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.damage_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CS_ATTACK::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> CS_ATTACK::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CS_ATTACK, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CS_ATTACK_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // int64 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(CS_ATTACK, _impl_.id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(CS_ATTACK, _impl_.id_)}},
    // .VECTOR3 attackPos = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(CS_ATTACK, _impl_.attackpos_)}},
    // float damage = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(CS_ATTACK, _impl_.damage_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 id = 1;
    {PROTOBUF_FIELD_OFFSET(CS_ATTACK, _impl_.id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // .VECTOR3 attackPos = 2;
    {PROTOBUF_FIELD_OFFSET(CS_ATTACK, _impl_.attackpos_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // float damage = 3;
    {PROTOBUF_FIELD_OFFSET(CS_ATTACK, _impl_.damage_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }}, {{
    {::_pbi::TcParser::GetTable<::VECTOR3>()},
  }}, {{
  }},
};

::uint8_t* CS_ATTACK::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CS_ATTACK)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_id(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .VECTOR3 attackPos = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::attackpos(this),
        _Internal::attackpos(this).GetCachedSize(), target, stream);
  }

  // float damage = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_damage = this->_internal_damage();
  ::uint32_t raw_damage;
  memcpy(&raw_damage, &tmp_damage, sizeof(tmp_damage));
  if (raw_damage != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_damage(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CS_ATTACK)
  return target;
}

::size_t CS_ATTACK::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CS_ATTACK)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .VECTOR3 attackPos = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.attackpos_);
  }

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  // float damage = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_damage = this->_internal_damage();
  ::uint32_t raw_damage;
  memcpy(&raw_damage, &tmp_damage, sizeof(tmp_damage));
  if (raw_damage != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CS_ATTACK::_class_data_ = {
    CS_ATTACK::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* CS_ATTACK::GetClassData() const {
  return &_class_data_;
}

void CS_ATTACK::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CS_ATTACK*>(&to_msg);
  auto& from = static_cast<const CS_ATTACK&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CS_ATTACK)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_attackpos()->::VECTOR3::MergeFrom(
        from._internal_attackpos());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_damage = from._internal_damage();
  ::uint32_t raw_damage;
  memcpy(&raw_damage, &tmp_damage, sizeof(tmp_damage));
  if (raw_damage != 0) {
    _this->_internal_set_damage(from._internal_damage());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CS_ATTACK::CopyFrom(const CS_ATTACK& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CS_ATTACK)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CS_ATTACK::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* CS_ATTACK::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CS_ATTACK::InternalSwap(CS_ATTACK* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CS_ATTACK, _impl_.damage_)
      + sizeof(CS_ATTACK::_impl_.damage_)
      - PROTOBUF_FIELD_OFFSET(CS_ATTACK, _impl_.attackpos_)>(
          reinterpret_cast<char*>(&_impl_.attackpos_),
          reinterpret_cast<char*>(&other->_impl_.attackpos_));
}

::google::protobuf::Metadata CS_ATTACK::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[14]);
}
// ===================================================================

class CS_HEAL::_Internal {
 public:
};

CS_HEAL::CS_HEAL(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CS_HEAL)
}
CS_HEAL::CS_HEAL(
    ::google::protobuf::Arena* arena, const CS_HEAL& from)
    : CS_HEAL(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CS_HEAL::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CS_HEAL::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.id_ = {};
}
CS_HEAL::~CS_HEAL() {
  // @@protoc_insertion_point(destructor:CS_HEAL)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CS_HEAL::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CS_HEAL::Clear() {
// @@protoc_insertion_point(message_clear_start:CS_HEAL)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = ::int64_t{0};
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CS_HEAL::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> CS_HEAL::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CS_HEAL_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // int64 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(CS_HEAL, _impl_.id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(CS_HEAL, _impl_.id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 id = 1;
    {PROTOBUF_FIELD_OFFSET(CS_HEAL, _impl_.id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CS_HEAL::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CS_HEAL)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CS_HEAL)
  return target;
}

::size_t CS_HEAL::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CS_HEAL)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CS_HEAL::_class_data_ = {
    CS_HEAL::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* CS_HEAL::GetClassData() const {
  return &_class_data_;
}

void CS_HEAL::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CS_HEAL*>(&to_msg);
  auto& from = static_cast<const CS_HEAL&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CS_HEAL)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CS_HEAL::CopyFrom(const CS_HEAL& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CS_HEAL)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CS_HEAL::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* CS_HEAL::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CS_HEAL::InternalSwap(CS_HEAL* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
        swap(_impl_.id_, other->_impl_.id_);
}

::google::protobuf::Metadata CS_HEAL::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[15]);
}
// ===================================================================

class CS_PRESSKEY::_Internal {
 public:
};

CS_PRESSKEY::CS_PRESSKEY(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CS_PRESSKEY)
}
CS_PRESSKEY::CS_PRESSKEY(
    ::google::protobuf::Arena* arena, const CS_PRESSKEY& from)
    : CS_PRESSKEY(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CS_PRESSKEY::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CS_PRESSKEY::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, key_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::key_));
}
CS_PRESSKEY::~CS_PRESSKEY() {
  // @@protoc_insertion_point(destructor:CS_PRESSKEY)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CS_PRESSKEY::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CS_PRESSKEY::Clear() {
// @@protoc_insertion_point(message_clear_start:CS_PRESSKEY)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.key_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.key_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CS_PRESSKEY::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> CS_PRESSKEY::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CS_PRESSKEY_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // int32 key = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CS_PRESSKEY, _impl_.key_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(CS_PRESSKEY, _impl_.key_)}},
    // int64 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(CS_PRESSKEY, _impl_.id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(CS_PRESSKEY, _impl_.id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 id = 1;
    {PROTOBUF_FIELD_OFFSET(CS_PRESSKEY, _impl_.id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // int32 key = 2;
    {PROTOBUF_FIELD_OFFSET(CS_PRESSKEY, _impl_.key_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CS_PRESSKEY::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CS_PRESSKEY)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_id(), target);
  }

  // int32 key = 2;
  if (this->_internal_key() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<2>(
            stream, this->_internal_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CS_PRESSKEY)
  return target;
}

::size_t CS_PRESSKEY::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CS_PRESSKEY)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  // int32 key = 2;
  if (this->_internal_key() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_key());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CS_PRESSKEY::_class_data_ = {
    CS_PRESSKEY::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* CS_PRESSKEY::GetClassData() const {
  return &_class_data_;
}

void CS_PRESSKEY::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CS_PRESSKEY*>(&to_msg);
  auto& from = static_cast<const CS_PRESSKEY&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CS_PRESSKEY)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_key() != 0) {
    _this->_internal_set_key(from._internal_key());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CS_PRESSKEY::CopyFrom(const CS_PRESSKEY& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CS_PRESSKEY)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CS_PRESSKEY::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* CS_PRESSKEY::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CS_PRESSKEY::InternalSwap(CS_PRESSKEY* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CS_PRESSKEY, _impl_.key_)
      + sizeof(CS_PRESSKEY::_impl_.key_)
      - PROTOBUF_FIELD_OFFSET(CS_PRESSKEY, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::google::protobuf::Metadata CS_PRESSKEY::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[16]);
}
// ===================================================================

class CS_PLAYERORDER::_Internal {
 public:
};

CS_PLAYERORDER::CS_PLAYERORDER(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CS_PLAYERORDER)
}
CS_PLAYERORDER::CS_PLAYERORDER(
    ::google::protobuf::Arena* arena, const CS_PLAYERORDER& from)
    : CS_PLAYERORDER(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CS_PLAYERORDER::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CS_PLAYERORDER::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, order_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::order_));
}
CS_PLAYERORDER::~CS_PLAYERORDER() {
  // @@protoc_insertion_point(destructor:CS_PLAYERORDER)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CS_PLAYERORDER::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CS_PLAYERORDER::Clear() {
// @@protoc_insertion_point(message_clear_start:CS_PLAYERORDER)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.order_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.order_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CS_PLAYERORDER::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> CS_PLAYERORDER::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CS_PLAYERORDER_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // int32 order = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CS_PLAYERORDER, _impl_.order_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(CS_PLAYERORDER, _impl_.order_)}},
    // int64 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(CS_PLAYERORDER, _impl_.id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(CS_PLAYERORDER, _impl_.id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 id = 1;
    {PROTOBUF_FIELD_OFFSET(CS_PLAYERORDER, _impl_.id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // int32 order = 2;
    {PROTOBUF_FIELD_OFFSET(CS_PLAYERORDER, _impl_.order_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CS_PLAYERORDER::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CS_PLAYERORDER)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_id(), target);
  }

  // int32 order = 2;
  if (this->_internal_order() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<2>(
            stream, this->_internal_order(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CS_PLAYERORDER)
  return target;
}

::size_t CS_PLAYERORDER::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CS_PLAYERORDER)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  // int32 order = 2;
  if (this->_internal_order() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_order());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CS_PLAYERORDER::_class_data_ = {
    CS_PLAYERORDER::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* CS_PLAYERORDER::GetClassData() const {
  return &_class_data_;
}

void CS_PLAYERORDER::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CS_PLAYERORDER*>(&to_msg);
  auto& from = static_cast<const CS_PLAYERORDER&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CS_PLAYERORDER)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_order() != 0) {
    _this->_internal_set_order(from._internal_order());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CS_PLAYERORDER::CopyFrom(const CS_PLAYERORDER& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CS_PLAYERORDER)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CS_PLAYERORDER::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* CS_PLAYERORDER::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CS_PLAYERORDER::InternalSwap(CS_PLAYERORDER* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CS_PLAYERORDER, _impl_.order_)
      + sizeof(CS_PLAYERORDER::_impl_.order_)
      - PROTOBUF_FIELD_OFFSET(CS_PLAYERORDER, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::google::protobuf::Metadata CS_PLAYERORDER::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[17]);
}
// ===================================================================

class CS_DAMAGED::_Internal {
 public:
};

CS_DAMAGED::CS_DAMAGED(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CS_DAMAGED)
}
CS_DAMAGED::CS_DAMAGED(
    ::google::protobuf::Arena* arena, const CS_DAMAGED& from)
    : CS_DAMAGED(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CS_DAMAGED::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CS_DAMAGED::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, id_),
           0,
           offsetof(Impl_, damage_) -
               offsetof(Impl_, id_) +
               sizeof(Impl_::damage_));
}
CS_DAMAGED::~CS_DAMAGED() {
  // @@protoc_insertion_point(destructor:CS_DAMAGED)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CS_DAMAGED::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CS_DAMAGED::Clear() {
// @@protoc_insertion_point(message_clear_start:CS_DAMAGED)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.id_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.damage_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.damage_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CS_DAMAGED::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> CS_DAMAGED::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CS_DAMAGED_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // float damage = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(CS_DAMAGED, _impl_.damage_)}},
    // int64 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(CS_DAMAGED, _impl_.id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(CS_DAMAGED, _impl_.id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 id = 1;
    {PROTOBUF_FIELD_OFFSET(CS_DAMAGED, _impl_.id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // float damage = 2;
    {PROTOBUF_FIELD_OFFSET(CS_DAMAGED, _impl_.damage_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CS_DAMAGED::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CS_DAMAGED)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_id(), target);
  }

  // float damage = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_damage = this->_internal_damage();
  ::uint32_t raw_damage;
  memcpy(&raw_damage, &tmp_damage, sizeof(tmp_damage));
  if (raw_damage != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_damage(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CS_DAMAGED)
  return target;
}

::size_t CS_DAMAGED::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CS_DAMAGED)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  // float damage = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_damage = this->_internal_damage();
  ::uint32_t raw_damage;
  memcpy(&raw_damage, &tmp_damage, sizeof(tmp_damage));
  if (raw_damage != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CS_DAMAGED::_class_data_ = {
    CS_DAMAGED::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* CS_DAMAGED::GetClassData() const {
  return &_class_data_;
}

void CS_DAMAGED::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CS_DAMAGED*>(&to_msg);
  auto& from = static_cast<const CS_DAMAGED&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CS_DAMAGED)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_damage = from._internal_damage();
  ::uint32_t raw_damage;
  memcpy(&raw_damage, &tmp_damage, sizeof(tmp_damage));
  if (raw_damage != 0) {
    _this->_internal_set_damage(from._internal_damage());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CS_DAMAGED::CopyFrom(const CS_DAMAGED& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CS_DAMAGED)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CS_DAMAGED::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* CS_DAMAGED::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CS_DAMAGED::InternalSwap(CS_DAMAGED* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CS_DAMAGED, _impl_.damage_)
      + sizeof(CS_DAMAGED::_impl_.damage_)
      - PROTOBUF_FIELD_OFFSET(CS_DAMAGED, _impl_.id_)>(
          reinterpret_cast<char*>(&_impl_.id_),
          reinterpret_cast<char*>(&other->_impl_.id_));
}

::google::protobuf::Metadata CS_DAMAGED::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[18]);
}
// ===================================================================

class CS_DISCONNECT::_Internal {
 public:
};

CS_DISCONNECT::CS_DISCONNECT(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:CS_DISCONNECT)
}
CS_DISCONNECT::CS_DISCONNECT(
    ::google::protobuf::Arena* arena, const CS_DISCONNECT& from)
    : CS_DISCONNECT(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CS_DISCONNECT::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CS_DISCONNECT::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.id_ = {};
}
CS_DISCONNECT::~CS_DISCONNECT() {
  // @@protoc_insertion_point(destructor:CS_DISCONNECT)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CS_DISCONNECT::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CS_DISCONNECT::Clear() {
// @@protoc_insertion_point(message_clear_start:CS_DISCONNECT)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = ::int64_t{0};
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CS_DISCONNECT::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> CS_DISCONNECT::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CS_DISCONNECT_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // int64 id = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(CS_DISCONNECT, _impl_.id_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(CS_DISCONNECT, _impl_.id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int64 id = 1;
    {PROTOBUF_FIELD_OFFSET(CS_DISCONNECT, _impl_.id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* CS_DISCONNECT::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CS_DISCONNECT)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CS_DISCONNECT)
  return target;
}

::size_t CS_DISCONNECT::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CS_DISCONNECT)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CS_DISCONNECT::_class_data_ = {
    CS_DISCONNECT::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* CS_DISCONNECT::GetClassData() const {
  return &_class_data_;
}

void CS_DISCONNECT::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CS_DISCONNECT*>(&to_msg);
  auto& from = static_cast<const CS_DISCONNECT&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CS_DISCONNECT)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CS_DISCONNECT::CopyFrom(const CS_DISCONNECT& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CS_DISCONNECT)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CS_DISCONNECT::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* CS_DISCONNECT::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CS_DISCONNECT::InternalSwap(CS_DISCONNECT* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
        swap(_impl_.id_, other->_impl_.id_);
}

::google::protobuf::Metadata CS_DISCONNECT::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_Protocol_2eproto_getter, &descriptor_table_Protocol_2eproto_once,
      file_level_metadata_Protocol_2eproto[19]);
}
// @@protoc_insertion_point(namespace_scope)
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
