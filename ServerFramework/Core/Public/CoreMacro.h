#ifndef _SERVERFRAMEWORK_CORE_PUBLIC_COREMACRO_H
#define _SERVERFRAMEWORK_CORE_PUBLIC_COREMACRO_H

/*
==========================
					SHOW
==========================
*/

/*
@ Date: 2023-12-28
@ Writer: 박태현
@ Explain:  함수를 실행시킬 때, 레퍼런스를 통해 해당하는 변수의 값이 바뀔 수 있을 경우를 나타냄
*/
#define REF_OUT

/*
@ Date: 2023-12-28
@ Writer: 박태현
@ Explain:  함수를 선언할 때, 레퍼런스를 통해 해당하는 변수의 값이 바뀔 수 있을 경우를 나타냄
*/
#define REF_INNER 


/*
@ Date: 2023-12-28
@ Writer: 박태현
@ Explain: 함수를 실행시킬 때,  Pointer를 통해 해당하는 변수의 값이 바뀔 수 있음을 나타냄
*/
#define POINTER_OUT 


/*
@ Date: 2023-12-28
@ Writer: 박태현
@ Explain: 함수를 선언할 때,  Pointer를 통해 해당하는 변수의 값이 바뀔 수 있음을 나타냄
*/
#define POINTER_INNTER 

/*
@ Date: 2023-12-28
@ Writer: 박태현
@ Explain: 읽기 전용 변수를 나타낸다.
*/
#define READONLY

/*
==========================
					LOCK	
==========================
@ Date: 2023-12-28
@ Writer: 박태현
@ Explain: 매크로로 Lock들을 다룰때 사용한다.
*/


#ifdef USE_DEBUG
#define		READ_LOCK_IDX(idx)				Core::ReadLockGuard readLockGuard_##idx(_locks[idx], typeid(this).name());
#define		WRITE_LOCK_IDX(idx)				Core::WriteLockGuard writeLockGuard_##idx(_locks[idx], typeid(this).name());
#else
#define		READ_LOCK_IDX(idx)				Core::ReadLockGuard readLockGuard_##idx(_locks[idx]);
#define		WRITE_LOCK_IDX(idx)				Core::WriteLockGuard writeLockGuard_##idx(_locks[idx]);
#endif

#define		USE_MANY_LOCKS(count)		ARRAY<Core::RWLock, count>;
#define		USE_LOCK									USE_MANY_LOCKS(1)
#define		READ_LOCK								READ_LOCK_IDX(0)
#define		WRITE_LOCK								READ_LOCK_IDX(0)

/*
==========================
					DEBUG
==========================
*/

/*
@ Date: 2023-12-26
@ Writer: 박태현
@ Explain: 강제로 크래쉬를 일으키는 매크로
*/
#define CRASH(Value) Core::DEBUG::Crash(Value);
#define ASSERT_CRASH(COND, Value) Core::DEBUG::AssertCrash(Value, COND);

/*
@ Date: 2023-12-26
@ Writer: 박태현
@ Explain: DEBUG_MACRO를 위한 FILE_LINE_FUNCTION등을 정의 
*/
#define DEBUG_MACRO_TO_METHOD \
__FILE__, __LINE__, __FUNCTION__ 
#define LOG_MACRO_TO_METHOD(x) \
typeid(x).name() , __LINE__, __FUNCTION__

/*
@ Date: 2023-12-26
@ Writer: 박태현
@ Explain: NULL이면 Message 박스 출력
*/
#ifdef USE_DEBUG

#define ISNULLPTR(T) \
Is_Nullptr_Debug(T, DEBUG_MACRO_TO_METHOD)

#endif 



/*
==========================
					CLASS
==========================
*/


/*
@ Date: 2023-12-26
@ Writer: 박태현
@ Explain: NO_COPY 매크로가 존재하면 복제 불가한 클래스라는 말이다. 
*/
#define NO_COPY(ClassName)							\
public: \
ClassName(const ClassName&) = delete;					\
ClassName& operator=(const ClassName&) = delete; 

/*
@ Date: 2023-12-26
@ Writer: 박태현
@ Explain: 소멸자에 Free를 호출하게 만드는 매크로
*/
#define DESTRUCTOR(ClassName) virtual ~ClassName() {Free();}

/*
@ Date: 2023-12-26
@ Writer: 박태현
@ Explain: 헤더파일에 싱글톤에 사용할 함수와 변수를 정의
*/
#define DECLARE_SINGLETON(ClassName)					\
		NO_COPY(ClassName)								\
public :												\
	static  SHPTR<ClassName> GetInstance();					\
	static  void DestoryInstance();		\
private:												\
	static SHPTR<ClassName> m_pInstance;

/*
@ Date: 2023-12-26
@ Writer: 박태현
@ Explain: 헤더파일에서 정의한 함수와 변수를 CPP파일에서 초기화 그리고 정의하여 싱글톤이 되도록한다. 
*/
#define IMPLEMENT_SINGLETON(ClassName)					\
SHPTR<ClassName> ClassName::m_pInstance = nullptr;			\
SHPTR<ClassName> ClassName::GetInstance()					\
{														\
	if (nullptr == m_pInstance)							\
		m_pInstance = Core::PTH::MakeShared<ClassName>(std::make_shared<ClassName>());		\
	return m_pInstance;									\
}														\
void ClassName::DestoryInstance(){  m_pInstance.reset(); }		

/*
@ Date: 2023-12-26
@ Writer: 박태현
@ Explain: 싱글톤 클래스의 값을 받아오는 매크로
*/
#define GET_INSTANCE(CLASSNAME) [](){ \
  SHPTR<CLASSNAME> pInstance = CLASSNAME::GetInstance();	\
    return pInstance; \
}();


/*
@ Date: 2023-12-26
@ Writer: 박태현
@ Explain:  DLL 파일 관리하는 매크로, EXPORT 일때와 Exprot 아닐 때 구분하게 해준다. 
*/
#ifdef CORE_EXPORTS
#define CORE_DLL   _declspec(dllexport)
#define CACHE_ALGIN_CORE_DLL  _declspec(dllexport) __declspec(align(16))
#else
#define CORE_DLL  _declspec(dllimport)
#define CACHE_ALGIN_CORE_DLL  _declspec(dllimport) __declspec(align(16))
#endif



/*
==========================
					ECT
==========================
*/

/*
@ Date: 2023-12-26
@ Writer: 박태현
@ Explain: namespace의 시작과 끝을 구분하는 영역 지정
*/
#define BEGIN(NAME) namespace NAME{
#define END }

/*
@ Date: 2023-12-26
@ Writer: 박태현
@ Explain: 조건에 맞으면 리턴하는 메크로
*/
#define RETURN_CHECK(SITUATION, RETURN) if(SITUATION) return RETURN;

#endif // _SERVERFRAMEWORK_CORE_PUBLIC_COREMACRO_H